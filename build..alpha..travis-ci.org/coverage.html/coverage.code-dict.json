{"/home/travis/build/npmtest/node-npmtest-ioredis/test.js":"/* istanbul instrument in package npmtest_ioredis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ioredis/lib.npmtest_ioredis.js":"/* istanbul instrument in package npmtest_ioredis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ioredis = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ioredis = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ioredis/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ioredis && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ioredis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ioredis\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ioredis.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ioredis.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ioredis.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ioredis.__dirname + '/lib.npmtest_ioredis.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/index.js":"'use strict';\n\nexports = module.exports = require('./lib/redis');\n\nexports.ReplyError = require('./lib/reply_error');\nexports.Promise = require('bluebird');\nexports.Cluster = require('./lib/cluster');\nexports.Command = require('./lib/command');\n\nexports.print = function (err, reply) {\n  if (err) {\n    console.log('Error: ' + err);\n  } else {\n    console.log('Reply: ' + reply);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/redis.js":"'use strict';\n\nvar _ = require('lodash');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar Promise = require('bluebird');\nvar Deque = require('double-ended-queue');\nvar Command = require('./command');\nvar Commander = require('./commander');\nvar utils = require('./utils');\nvar eventHandler = require('./redis/event_handler');\nvar debug = require('debug')('ioredis:redis');\nvar Connector = require('./connectors/connector');\nvar SentinelConnector = require('./connectors/sentinel_connector');\nvar ScanStream = require('./scan_stream');\nvar commands = require('redis-commands');\n\n/**\n * Creates a Redis instance\n *\n * @constructor\n * @param {(number|string|Object)} [port=6379] - Port of the Redis server,\n * or a URL string(see the examples below),\n * or the `options` object(see the third argument).\n * @param {string|Object} [host=localhost] - Host of the Redis server,\n * when the first argument is a URL string,\n * this argument is an object represents the options.\n * @param {Object} [options] - Other options.\n * @param {number} [options.port=6379] - Port of the Redis server.\n * @param {string} [options.host=localhost] - Host of the Redis server.\n * @param {string} [options.family=4] - Version of IP stack. Defaults to 4.\n * @param {string} [options.path=null] - Local domain socket path. If set the `port`,\n * `host` and `family` will be ignored.\n * @param {number} [options.keepAlive=0] - TCP KeepAlive on the socket with a X ms delay before start.\n * Set to a non-number value to disable keepAlive.\n * @param {boolean} [options.noDelay=true] - Whether to disable the Nagle's Algorithm. By default we disable\n * it to reduce the latency.\n * @param {string} [options.connectionName=null] - Connection name.\n * @param {number} [options.db=0] - Database index to use.\n * @param {string} [options.password=null] - If set, client will send AUTH command\n * with the value of this option when connected.\n * @param {string} [options.parser=null] - Either \"hiredis\" or \"javascript\". If not set, \"hiredis\" parser\n * will be used if it's installed (`npm install hiredis`), otherwise \"javascript\" parser will be used.\n * @param {boolean} [options.dropBufferSupport=false] - Drop the buffer support for better performance.\n * This option is recommended to be enabled when \"hiredis\" parser is used.\n * Refer to https://github.com/luin/ioredis/wiki/Improve-Performance for more details.\n * @param {boolean} [options.enableReadyCheck=true] - When a connection is established to\n * the Redis server, the server might still be loading the database from disk.\n * While loading, the server not respond to any commands.\n * To work around this, when this option is `true`,\n * ioredis will check the status of the Redis server,\n * and when the Redis server is able to process commands,\n * a `ready` event will be emitted.\n * @param {boolean} [options.enableOfflineQueue=true] - By default,\n * if there is no active connection to the Redis server,\n * commands are added to a queue and are executed once the connection is \"ready\"\n * (when `enableReadyCheck` is `true`,\n * \"ready\" means the Redis server has loaded the database from disk, otherwise means the connection\n * to the Redis server has been established). If this option is false,\n * when execute the command when the connection isn't ready, an error will be returned.\n * @param {number} [options.connectTimeout=10000] - The milliseconds before a timeout occurs during the initial\n * connection to the Redis server.\n * @param {boolean} [options.autoResubscribe=true] - After reconnected, if the previous connection was in the\n * subscriber mode, client will auto re-subscribe these channels.\n * @param {boolean} [options.autoResendUnfulfilledCommands=true] - If true, client will resend unfulfilled\n * commands(e.g. block commands) in the previous connection when reconnected.\n * @param {boolean} [options.lazyConnect=false] - By default,\n * When a new `Redis` instance is created, it will connect to Redis server automatically.\n * If you want to keep disconnected util a command is called, you can pass the `lazyConnect` option to\n * the constructor:\n *\n * ```javascript\n * var redis = new Redis({ lazyConnect: true });\n * // No attempting to connect to the Redis server here.\n\n * // Now let's connect to the Redis server\n * redis.get('foo', function () {\n * });\n * ```\n * @param {string} [options.keyPrefix=''] - The prefix to prepend to all keys in a command.\n * @param {function} [options.retryStrategy] - See \"Quick Start\" section\n * @param {function} [options.reconnectOnError] - See \"Quick Start\" section\n * @param {boolean} [options.readOnly=false] - Enable READONLY mode for the connection.\n * Only available for cluster mode.\n * @param {boolean} [options.stringNumbers=false] - Force numbers to be always returned as JavaScript\n * strings. This option is necessary when dealing with big numbers (exceed the [-2^53, +2^53] range).\n * Notice that when this option is enabled, the JavaScript parser will be used even \"hiredis\" is specified\n * because only JavaScript parser supports this feature for the time being.\n * @extends [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * @extends Commander\n * @example\n * ```js\n * var Redis = require('ioredis');\n *\n * var redis = new Redis();\n * // or: var redis = Redis();\n *\n * var redisOnPort6380 = new Redis(6380);\n * var anotherRedis = new Redis(6380, '192.168.100.1');\n * var unixSocketRedis = new Redis({ path: '/tmp/echo.sock' });\n * var unixSocketRedis2 = new Redis('/tmp/echo.sock');\n * var urlRedis = new Redis('redis://user:password@redis-service.com:6379/');\n * var urlRedis2 = new Redis('//localhost:6379');\n * var authedRedis = new Redis(6380, '192.168.100.1', { password: 'password' });\n * ```\n */\nfunction Redis() {\n  if (!(this instanceof Redis)) {\n    return new Redis(arguments[0], arguments[1], arguments[2]);\n  }\n\n  EventEmitter.call(this);\n  Commander.call(this);\n\n  this.parseOptions(arguments[0], arguments[1], arguments[2]);\n\n  this.resetCommandQueue();\n  this.resetOfflineQueue();\n\n  if (this.options.sentinels) {\n    this.connector = new SentinelConnector(this.options);\n  } else {\n    this.connector = new Connector(this.options);\n  }\n\n  this.retryAttempts = 0;\n\n  // end(or wait) -> connecting -> connect -> ready -> end\n  if (this.options.lazyConnect) {\n    this.setStatus('wait');\n  } else {\n    this.connect().catch(_.noop);\n  }\n}\n\nutil.inherits(Redis, EventEmitter);\n_.assign(Redis.prototype, Commander.prototype);\n\n/**\n * Create a Redis instance\n *\n * @deprecated\n */\nRedis.createClient = function () {\n  return Redis.apply(this, arguments);\n};\n\n/**\n * Default options\n *\n * @var defaultOptions\n * @protected\n */\nRedis.defaultOptions = {\n  // Connection\n  port: 6379,\n  host: 'localhost',\n  family: 4,\n  connectTimeout: 3000,\n  retryStrategy: function (times) {\n    return Math.min(times * 2, 2000);\n  },\n  keepAlive: 0,\n  noDelay: true,\n  connectionName: null,\n  // Sentinel\n  sentinels: null,\n  name: null,\n  role: 'master',\n  sentinelRetryStrategy: function (times) {\n    return Math.min(times * 10, 1000);\n  },\n  // Status\n  password: null,\n  db: 0,\n  // Others\n  parser: null,\n  dropBufferSupport: false,\n  enableOfflineQueue: true,\n  enableReadyCheck: true,\n  autoResubscribe: true,\n  autoResendUnfulfilledCommands: true,\n  lazyConnect: false,\n  keyPrefix: '',\n  reconnectOnError: null,\n  readOnly: false,\n  stringNumbers: false\n};\n\nRedis.prototype.resetCommandQueue = function () {\n  this.commandQueue = new Deque();\n};\n\nRedis.prototype.resetOfflineQueue = function () {\n  this.offlineQueue = new Deque();\n};\n\nRedis.prototype.parseOptions = function () {\n  this.options = {};\n  for (var i = 0; i < arguments.length; ++i) {\n    var arg = arguments[i];\n    if (arg === null || typeof arg === 'undefined') {\n      continue;\n    }\n    if (typeof arg === 'object') {\n      _.defaults(this.options, arg);\n    } else if (typeof arg === 'string') {\n      _.defaults(this.options, utils.parseURL(arg));\n    } else if (typeof arg === 'number') {\n      this.options.port = arg;\n    } else {\n      throw new Error('Invalid argument ' + arg);\n    }\n  }\n  _.defaults(this.options, Redis.defaultOptions);\n\n  if (typeof this.options.port === 'string') {\n    this.options.port = parseInt(this.options.port, 10);\n  }\n  if (typeof this.options.db === 'string') {\n    this.options.db = parseInt(this.options.db, 10);\n  }\n};\n\n/**\n * Change instance's status\n * @private\n */\nRedis.prototype.setStatus = function (status, arg) {\n  var address;\n  if (this.options.path) {\n    address = this.options.path;\n  } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {\n    address = this.stream.remoteAddress + ':' + this.stream.remotePort;\n  } else {\n    address = this.options.host + ':' + this.options.port;\n  }\n\n  debug('status[%s]: %s -> %s', address, this.status || '[empty]', status);\n  this.status = status;\n  process.nextTick(this.emit.bind(this, status, arg));\n};\n\n/**\n * Create a connection to Redis.\n * This method will be invoked automatically when creating a new Redis instance.\n * @param {function} callback\n * @return {Promise}\n * @public\n */\nRedis.prototype.connect = function (callback) {\n  return new Promise(function (resolve, reject) {\n    if (this.status === 'connecting' || this.status === 'connect' || this.status === 'ready') {\n      reject(new Error('Redis is already connecting/connected'));\n      return;\n    }\n    this.setStatus('connecting');\n\n    this.condition = {\n      select: this.options.db,\n      auth: this.options.password,\n      subscriber: false\n    };\n\n    var _this = this;\n    this.connector.connect(function (err, stream) {\n      if (err) {\n        _this.flushQueue(err);\n        _this.silentEmit('error', err);\n        reject(err);\n        _this.setStatus('end');\n        return;\n      }\n      var CONNECT_EVENT = _this.options.tls ? 'secureConnect' : 'connect';\n\n      _this.stream = stream;\n      if (typeof _this.options.keepAlive === 'number') {\n        stream.setKeepAlive(true, _this.options.keepAlive);\n      }\n\n      stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n      stream.once('error', eventHandler.errorHandler(_this));\n      stream.once('close', eventHandler.closeHandler(_this));\n      stream.on('data', eventHandler.dataHandler(_this));\n\n      if (_this.options.connectTimeout) {\n        stream.setTimeout(_this.options.connectTimeout, function () {\n          stream.setTimeout(0);\n          stream.destroy();\n\n          var err = new Error('connect ETIMEDOUT');\n          err.errorno = 'ETIMEDOUT';\n          err.code = 'ETIMEDOUT';\n          err.syscall = 'connect';\n          eventHandler.errorHandler(_this)(err);\n        });\n        stream.once(CONNECT_EVENT, function () {\n          stream.setTimeout(0);\n        });\n      }\n\n      if (_this.options.noDelay) {\n        stream.setNoDelay(true);\n      }\n\n      var connectionConnectHandler = function () {\n        _this.removeListener('close', connectionCloseHandler);\n        resolve();\n      };\n      var connectionCloseHandler = function () {\n        _this.removeListener(CONNECT_EVENT, connectionConnectHandler);\n        reject(new Error(utils.CONNECTION_CLOSED_ERROR_MSG));\n      };\n      _this.once(CONNECT_EVENT, connectionConnectHandler);\n      _this.once('close', connectionCloseHandler);\n    });\n  }.bind(this)).nodeify(callback);\n};\n\n/**\n * Disconnect from Redis.\n *\n * This method closes the connection immediately,\n * and may lose some pending replies that haven't written to client.\n * If you want to wait for the pending replies, use Redis#quit instead.\n * @public\n */\nRedis.prototype.disconnect = function (reconnect) {\n  if (!reconnect) {\n    this.manuallyClosing = true;\n  }\n  if (this.reconnectTimeout) {\n    clearTimeout(this.reconnectTimeout);\n    this.reconnectTimeout = null;\n  }\n  if (this.status === 'wait') {\n    eventHandler.closeHandler(this)();\n  } else {\n    this.connector.disconnect();\n  }\n};\n\n/**\n * Disconnect from Redis.\n *\n * @deprecated\n */\nRedis.prototype.end = function () {\n  this.disconnect();\n};\n\n/**\n * Create a new instance with the same options as the current one.\n *\n * @example\n * ```js\n * var redis = new Redis(6380);\n * var anotherRedis = redis.duplicate();\n * ```\n *\n * @public\n */\nRedis.prototype.duplicate = function (override) {\n  return new Redis(_.assign(_.cloneDeep(this.options), override || {}));\n};\n\n/**\n * Flush offline queue and command queue with error.\n *\n * @param {Error} error - The error object to send to the commands\n * @param {object} options\n * @private\n */\nRedis.prototype.flushQueue = function (error, options) {\n  options = _.defaults({}, options, {\n    offlineQueue: true,\n    commandQueue: true\n  });\n\n  var item;\n  if (options.offlineQueue) {\n    while (this.offlineQueue.length > 0) {\n      item = this.offlineQueue.shift();\n      item.command.reject(error);\n    }\n  }\n\n  if (options.commandQueue) {\n    if (this.commandQueue.length > 0) {\n      if (this.stream) {\n        this.stream.removeAllListeners('data');\n      }\n      while (this.commandQueue.length > 0) {\n        item = this.commandQueue.shift();\n        item.command.reject(error);\n      }\n    }\n  }\n};\n\n/**\n * Check whether Redis has finished loading the persistent data and is able to\n * process commands.\n *\n * @param {Function} callback\n * @private\n */\nRedis.prototype._readyCheck = function (callback) {\n  var _this = this;\n  this.info(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (typeof res !== 'string') {\n      return callback(null, res);\n    }\n\n    var info = {};\n\n    var lines = res.split('\\r\\n');\n    for (var i = 0; i < lines.length; ++i) {\n      var parts = lines[i].split(':');\n      if (parts[1]) {\n        info[parts[0]] = parts[1];\n      }\n    }\n\n    if (!info.loading || info.loading === '0') {\n      callback(null, info);\n    } else {\n      var retryTime = (info.loading_eta_seconds || 1) * 1000;\n      debug('Redis server still loading, trying again in ' + retryTime + 'ms');\n      setTimeout(function () {\n        _this._readyCheck(callback);\n      }, retryTime);\n    }\n  });\n};\n\n/**\n * Emit only when there's at least one listener.\n *\n * @param {string} eventName - Event to emit\n * @param {...*} arguments - Arguments\n * @return {boolean} Returns true if event had listeners, false otherwise.\n * @private\n */\nRedis.prototype.silentEmit = function (eventName) {\n  var error;\n  if (eventName === 'error') {\n    error = arguments[1];\n\n    if (this.status === 'end') {\n      return;\n    }\n\n    if (this.manuallyClosing) {\n      // ignore connection related errors when manually disconnecting\n      if (\n        error instanceof Error &&\n        (\n          error.message === utils.CONNECTION_CLOSED_ERROR_MSG ||\n          error.syscall === 'connect' ||\n          error.syscall === 'read'\n        )\n      ) {\n        return;\n      }\n    }\n  }\n  if (this.listeners(eventName).length > 0) {\n    return this.emit.apply(this, arguments);\n  }\n  if (error && error instanceof Error) {\n    console.error('[ioredis] Unhandled error event:', error.stack);\n  }\n  return false;\n};\n\n/**\n * Listen for all requests received by the server in real time.\n *\n * This command will create a new connection to Redis and send a\n * MONITOR command via the new connection in order to avoid disturbing\n * the current connection.\n *\n * @param {function} [callback] The callback function. If omit, a promise will be returned.\n * @example\n * ```js\n * var redis = new Redis();\n * redis.monitor(function (err, monitor) {\n *   // Entering monitoring mode.\n *   monitor.on('monitor', function (time, args, source, database) {\n *     console.log(time + \": \" + util.inspect(args));\n *   });\n * });\n *\n * // supports promise as well as other commands\n * redis.monitor().then(function (monitor) {\n *   monitor.on('monitor', function (time, args, source, database) {\n *     console.log(time + \": \" + util.inspect(args));\n *   });\n * });\n * ```\n * @public\n */\nRedis.prototype.monitor = function (callback) {\n  var monitorInstance = this.duplicate({\n    monitor: true,\n    lazyConnect: false\n  });\n\n  return new Promise(function (resolve) {\n    monitorInstance.once('monitoring', function () {\n      resolve(monitorInstance);\n    });\n  }).nodeify(callback);\n};\n\nrequire('./transaction').addTransactionSupport(Redis.prototype);\n\n/**\n * Send a command to Redis\n *\n * This method is used internally by the `Redis#set`, `Redis#lpush` etc.\n * Most of the time you won't invoke this method directly.\n * However when you want to send a command that is not supported by ioredis yet,\n * this command will be useful.\n *\n * @method sendCommand\n * @memberOf Redis#\n * @param {Command} command - The Command instance to send.\n * @see {@link Command}\n * @example\n * ```js\n * var redis = new Redis();\n *\n * // Use callback\n * var get = new Command('get', ['foo'], 'utf8', function (err, result) {\n *   console.log(result);\n * });\n * redis.sendCommand(get);\n *\n * // Use promise\n * var set = new Command('set', ['foo', 'bar'], 'utf8');\n * set.promise.then(function (result) {\n *   console.log(result);\n * });\n * redis.sendCommand(set);\n * ```\n * @private\n */\nRedis.prototype.sendCommand = function (command, stream) {\n  if (this.status === 'wait') {\n    this.connect().catch(_.noop);\n  }\n  if (this.status === 'end') {\n    command.reject(new Error(utils.CONNECTION_CLOSED_ERROR_MSG));\n    return command.promise;\n  }\n  if (this.condition.subscriber && !Command.checkFlag('VALID_IN_SUBSCRIBER_MODE', command.name)) {\n    command.reject(new Error('Connection in subscriber mode, only subscriber commands may be used'));\n    return command.promise;\n  }\n\n  var writable = (this.status === 'ready') ||\n    (!stream && (this.status === 'connect') && commands.hasFlag(command.name, 'loading'));\n  if (!this.stream) {\n    writable = false;\n  } else if (!this.stream.writable) {\n    writable = false;\n  } else if (this.stream._writableState && this.stream._writableState.ended) {\n    // https://github.com/iojs/io.js/pull/1217\n    writable = false;\n  }\n\n  if (!writable && !this.options.enableOfflineQueue) {\n    command.reject(new Error('Stream isn\\'t writeable and enableOfflineQueue options is false'));\n    return command.promise;\n  }\n\n  if (!writable && command.name === 'quit' && this.offlineQueue.length === 0) {\n    this.disconnect();\n    command.resolve(new Buffer('OK'));\n    return command.promise;\n  }\n\n  if (writable) {\n    debug('write command[%d] -> %s(%s)', this.condition.select, command.name, command.args);\n    (stream || this.stream).write(command.toWritable());\n\n    this.commandQueue.push({\n      command: command,\n      stream: stream,\n      select: this.condition.select\n    });\n\n    if (Command.checkFlag('WILL_DISCONNECT', command.name)) {\n      this.manuallyClosing = true;\n    }\n  } else if (this.options.enableOfflineQueue) {\n    debug('queue command[%d] -> %s(%s)', this.condition.select, command.name, command.args);\n    this.offlineQueue.push({\n      command: command,\n      stream: stream,\n      select: this.condition.select\n    });\n  }\n\n  if (command.name === 'select' && utils.isInt(command.args[0])) {\n    var db = parseInt(command.args[0], 10);\n    if (this.condition.select !== db) {\n      this.condition.select = db;\n      this.emit('select', db);\n      debug('switch to db [%d]', this.condition.select);\n    }\n  }\n\n  return command.promise;\n};\n\n['scan', 'sscan', 'hscan', 'zscan', 'scanBuffer', 'sscanBuffer', 'hscanBuffer', 'zscanBuffer']\n.forEach(function (command) {\n  Redis.prototype[command + 'Stream'] = function (key, options) {\n    if (command === 'scan' || command === 'scanBuffer') {\n      options = key;\n      key = null;\n    }\n    return new ScanStream(_.defaults({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command\n    }, options));\n  };\n});\n\n_.assign(Redis.prototype, require('./redis/parser'));\n\nmodule.exports = Redis;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/command.js":"'use strict';\n\nvar _ = require('lodash');\nvar Promise = require('bluebird');\nvar fbuffer = require('flexbuffer');\nvar utils = require('./utils');\nvar commands = require('redis-commands');\nvar calculateSlot = require('cluster-key-slot');\n\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * @constructor\n * @param {string} name - Command name\n * @param {string[]} [args=null] - An array of command arguments\n * @param {object} [options]\n * @param {string} [options.replyEncoding=null] - Set the encoding of the reply,\n * by default buffer will be returned.\n * @param {function} [callback=null] - The callback that handles the response.\n * If omit, the response will be handled via Promise.\n * @example\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n *\n * @see {@link Redis#sendCommand} which can send a Command instance to Redis\n * @public\n */\nfunction Command(name, args, options, callback) {\n  if (typeof options === 'undefined') {\n    options = {};\n  }\n  this.name = name;\n  this.replyEncoding = options.replyEncoding;\n  this.errorStack = options.errorStack;\n  this.args = args ? _.flatten(args) : [];\n  this.callback = callback;\n  this.initPromise();\n\n  var keyPrefix = options.keyPrefix;\n  if (keyPrefix) {\n    this._iterateKeys(function (key) {\n      return keyPrefix + key;\n    });\n  }\n}\n\nCommand.prototype.initPromise = function () {\n  var _this = this;\n  this.promise = new Promise(function (resolve, reject) {\n    if (!_this.transformed) {\n      _this.transformed = true;\n      var transformer = Command._transformer.argument[_this.name];\n      if (transformer) {\n        _this.args = transformer(_this.args);\n      }\n      _this.stringifyArguments();\n    }\n\n    _this.resolve = _this._convertValue(resolve);\n    if (_this.errorStack) {\n      _this.reject = function (err) {\n        reject(utils.optimizeErrorStack(err, _this.errorStack, __dirname));\n      };\n    } else {\n      _this.reject = reject;\n    }\n  }).nodeify(this.callback);\n};\n\nCommand.prototype.getSlot = function () {\n  if (typeof this._slot === 'undefined') {\n    var key = this.getKeys()[0];\n    if (key) {\n      this.slot = calculateSlot(key);\n    } else {\n      this.slot = null;\n    }\n  }\n  return this.slot;\n};\n\nCommand.prototype.getKeys = function () {\n  return this._iterateKeys();\n};\n\n/**\n * Iterate through the command arguments that are considered keys.\n *\n * @param {function} [transform] - The transformation that should be applied to\n * each key. The transformations will persist.\n * @return {string[]} The keys of the command.\n * @private\n */\nCommand.prototype._iterateKeys = function (transform) {\n  if (typeof this._keys === 'undefined') {\n    if (typeof transform !== 'function') {\n      transform = function (key) {\n        return key;\n      };\n    }\n    this._keys = [];\n    if (commands.exists(this.name)) {\n      var keyIndexes = commands.getKeyIndexes(this.name, this.args);\n      for (var i = 0; i < keyIndexes.length; i++) {\n        var index = keyIndexes[i];\n        this.args[index] = transform(this.args[index]);\n        this._keys.push(this.args[index]);\n      }\n    }\n  }\n  return this._keys;\n};\n\n/**\n * Convert command to writable buffer or string\n *\n * @return {string|Buffer}\n * @see {@link Redis#sendCommand}\n * @public\n */\nCommand.prototype.toWritable = function () {\n  var bufferMode = false;\n  var i;\n  for (i = 0; i < this.args.length; ++i) {\n    if (this.args[i] instanceof Buffer) {\n      bufferMode = true;\n      break;\n    }\n  }\n\n  var result, arg;\n  var commandStr = '*' + (this.args.length + 1) + '\\r\\n$' + this.name.length + '\\r\\n' + this.name + '\\r\\n';\n  if (bufferMode) {\n    var resultBuffer = new fbuffer.FlexBuffer(0);\n    resultBuffer.write(commandStr);\n    for (i = 0; i < this.args.length; ++i) {\n      arg = this.args[i];\n      if (arg instanceof Buffer) {\n        if (arg.length === 0) {\n          resultBuffer.write('$0\\r\\n\\r\\n');\n        } else {\n          resultBuffer.write('$' + arg.length + '\\r\\n');\n          resultBuffer.write(arg);\n          resultBuffer.write('\\r\\n');\n        }\n      } else {\n        resultBuffer.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n      }\n    }\n    result = resultBuffer.getBuffer();\n  } else {\n    result = commandStr;\n    for (i = 0; i < this.args.length; ++i) {\n      result += '$' + Buffer.byteLength(this.args[i]) + '\\r\\n' + this.args[i] + '\\r\\n';\n    }\n  }\n  return result;\n};\n\nCommand.prototype.stringifyArguments = function () {\n  for (var i = 0; i < this.args.length; ++i) {\n    if (!(this.args[i] instanceof Buffer) && typeof this.args[i] !== 'string') {\n      this.args[i] = utils.toArg(this.args[i]);\n    }\n  }\n};\n\n/**\n * Convert the value from buffer to the target encoding.\n *\n * @param {function} resolve - The resolve function of the Promise\n * @return {function} A funtion to transform and resolve a value\n * @private\n */\nCommand.prototype._convertValue = function (resolve) {\n  var _this = this;\n  return function (value) {\n    try {\n      resolve(_this.transformReply(value));\n    } catch (err) {\n      _this.reject(err);\n    }\n    return _this.promise;\n  };\n};\n\n/**\n * Convert buffer/buffer[] to string/string[],\n * and apply reply transformer.\n *\n * @public\n */\nCommand.prototype.transformReply = function (result) {\n  if (this.replyEncoding) {\n    result = utils.convertBufferToString(result, this.replyEncoding);\n  }\n  var transformer = Command._transformer.reply[this.name];\n  if (transformer) {\n    result = transformer(result);\n  }\n\n  return result;\n};\n\nCommand.FLAGS = {\n  // Commands that can be processed when client is in the subscriber mode\n  VALID_IN_SUBSCRIBER_MODE: ['subscribe', 'psubscribe', 'unsubscribe', 'punsubscribe', 'ping', 'quit'],\n  // Commands that are valid in monitor mode\n  VALID_IN_MONITOR_MODE: ['monitor', 'auth'],\n  // Commands that will turn current connection into subscriber mode\n  ENTER_SUBSCRIBER_MODE: ['subscribe', 'psubscribe'],\n  // Commands that may make current connection quit subscriber mode\n  EXIT_SUBSCRIBER_MODE: ['unsubscribe', 'punsubscribe'],\n  // Commands that will make client disconnect from server TODO shutdown?\n  WILL_DISCONNECT: ['quit']\n};\n\nvar flagMap = Object.keys(Command.FLAGS).reduce(function (map, flagName) {\n  map[flagName] = {};\n  Command.FLAGS[flagName].forEach(function (commandName) {\n    map[flagName][commandName] = true;\n  });\n  return map;\n}, {});\n\n/**\n * Check whether the command has the flag\n *\n * @param {string} flagName\n * @param {string} commandName\n * @return {boolean}\n */\nCommand.checkFlag = function (flagName, commandName) {\n  return !!flagMap[flagName][commandName];\n};\n\nCommand._transformer = {\n  argument: {},\n  reply: {}\n};\n\nCommand.setArgumentTransformer = function (name, func) {\n  Command._transformer.argument[name] = func;\n};\n\nCommand.setReplyTransformer = function (name, func) {\n  Command._transformer.reply[name] = func;\n};\n\nvar msetArgumentTransformer = function (args) {\n  if (args.length === 1) {\n    if (typeof Map !== 'undefined' && args[0] instanceof Map) {\n      return utils.convertMapToArray(args[0]);\n    }\n    if (typeof args[0] === 'object' && args[0] !== null) {\n      return utils.convertObjectToArray(args[0]);\n    }\n  }\n  return args;\n};\n\nCommand.setArgumentTransformer('mset', msetArgumentTransformer);\nCommand.setArgumentTransformer('msetnx', msetArgumentTransformer);\n\nCommand.setArgumentTransformer('hmset', function (args) {\n  if (args.length === 2) {\n    if (typeof Map !== 'undefined' && args[1] instanceof Map) {\n      return [args[0]].concat(utils.convertMapToArray(args[1]));\n    }\n    if (typeof args[1] === 'object' && args[1] !== null) {\n      return [args[0]].concat(utils.convertObjectToArray(args[1]));\n    }\n  }\n  return args;\n});\n\nCommand.setReplyTransformer('hgetall', function (result) {\n  if (Array.isArray(result)) {\n    var obj = {};\n    for (var i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/utils/index.js":"'use strict';\nvar urllib = require('url');\nvar _ = require('lodash');\n\n/**\n * Test if two buffers are equal\n *\n * @param {Buffer} a\n * @param {Buffer} b\n * @return {Boolean} Whether the two buffers are equal\n * @private\n */\nexports.bufferEqual = function (a, b) {\n  if (typeof a.equals === 'function') {\n    return a.equals(b);\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @param {*} value - The input value\n * @param {string} encoding - string encoding\n * @return {*} The result\n * @example\n * ```js\n * var input = [new Buffer('foo'), [new Buffer('bar')]];\n * var res = convertBufferToString(input, 'utf8');\n * expect(res).to.eql(['foo', ['bar']]);\n * ```\n * @private\n */\nexports.convertBufferToString = function (value, encoding) {\n  if (value instanceof Buffer) {\n    return value.toString(encoding);\n  }\n  if (Array.isArray(value)) {\n    var res = [];\n    for (var i = 0; i < value.length; ++i) {\n      res[i] = exports.convertBufferToString(value[i], encoding);\n    }\n    return res;\n  }\n  return value;\n};\n\n/**\n * Convert a list of results to node-style\n *\n * @param {Array} arr - The input value\n * @return {Array} The output value\n * @example\n * ```js\n * var input = ['a', 'b', new Error('c'), 'd'];\n * var output = exports.wrapMultiResult(input);\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd']);\n * ```\n * @private\n */\nexports.wrapMultiResult = function (arr) {\n  // When using WATCH/EXEC transactions, the EXEC will return\n  // a null instead of an array\n  if (!arr) {\n    return null;\n  }\n  var result = [];\n  var length = arr.length;\n  for (var i = 0; i < length; ++i) {\n    var item = arr[i];\n    if (item instanceof Error) {\n      result.push([item]);\n    } else {\n      result.push([null, item]);\n    }\n  }\n  return result;\n};\n\n/**\n * Detect the argument is a int\n *\n * @param {string} value\n * @return {boolean} Whether the value is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n * @private\n */\nexports.isInt = function (value) {\n  var x = parseFloat(value);\n  return !isNaN(value) && (x | 0) === x;\n};\n\n/**\n * Pack an array to an Object\n *\n * @param {array} array\n * @return {object}\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */\nexports.packObject = function (array) {\n  var result = {};\n  var length = array.length;\n\n  for (var i = 1; i < length; i += 2) {\n    result[array[i - 1]] = array[i];\n  }\n\n  return result;\n};\n\n/**\n * Return a callback with timeout\n *\n * @param {function} callback\n * @param {number} timeout\n * @return {function}\n */\nexports.timeout = function (callback, timeout) {\n  var timer;\n  var run = function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n      callback.apply(this, arguments);\n    }\n  };\n  timer = setTimeout(run, timeout, new Error('timeout'));\n  return run;\n};\n\n/**\n * Convert an object to an array\n *\n * @param {object} obj\n * @return {array}\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */\nexports.convertObjectToArray = function (obj) {\n  var result = [];\n  var pos = 0;\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      result[pos] = key;\n      result[pos + 1] = obj[key];\n    }\n    pos += 2;\n  }\n  return result;\n};\n\n/**\n * Convert a map to an array\n *\n * @param {Map} map\n * @return {array}\n * @example\n * ```js\n * > convertObjectToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */\nexports.convertMapToArray = function (map) {\n  var result = [];\n  var pos = 0;\n  map.forEach(function (value, key) {\n    result[pos] = key;\n    result[pos + 1] = value;\n    pos += 2;\n  });\n  return result;\n};\n\n/**\n * Convert a non-string arg to a string\n *\n * @param {*} arg\n * @return {string}\n */\nexports.toArg = function (arg) {\n  if (arg === null || typeof arg === 'undefined') {\n    return '';\n  }\n  return String(arg);\n};\n\n/**\n * Optimize error stack\n *\n * @param {Error} error - actually error\n * @param {string} friendlyStack - the stack that more meaningful\n * @param {string} filterPath - only show stacks with the specified path\n */\nexports.optimizeErrorStack = function (error, friendlyStack, filterPath) {\n  var stacks = friendlyStack.split('\\n');\n  var lines = '';\n  var i;\n  for (i = 1; i < stacks.length; ++i) {\n    if (stacks[i].indexOf(filterPath) === -1) {\n      break;\n    }\n  }\n  for (var j = i; j < stacks.length; ++j) {\n    lines += '\\n' + stacks[j];\n  }\n  var pos = error.stack.indexOf('\\n');\n  error.stack = error.stack.slice(0, pos) + lines;\n  return error;\n};\n\n/**\n * Parse the redis protocol url\n *\n * @param {string} url - the redis protocol url\n * @return {Object}\n */\nexports.parseURL = function (url) {\n  if (exports.isInt(url)) {\n    return { port: url };\n  }\n  var parsed = urllib.parse(url, true, true);\n\n  if (!parsed.slashes && url[0] !== '/') {\n    url = '//' + url;\n    parsed = urllib.parse(url, true, true);\n  }\n\n  var result = {};\n  if (parsed.auth) {\n    result.password = parsed.auth.split(':')[1];\n  }\n  if (parsed.pathname) {\n    if (parsed.protocol === 'redis:') {\n      if (parsed.pathname.length > 1) {\n        result.db = parsed.pathname.slice(1);\n      }\n    } else {\n      result.path = parsed.pathname;\n    }\n  }\n  if (parsed.host) {\n    result.host = parsed.hostname;\n  }\n  if (parsed.port) {\n    result.port = parsed.port;\n  }\n  _.defaults(result, parsed.query);\n\n  return result;\n};\n\n/**\n * Get a random element from `array`\n *\n * @param {array} array - the array\n * @param {number} [from=0] - start index\n * @return {}\n */\nexports.sample = function (array, from) {\n  var length = array.length;\n  if (typeof from !== 'number') {\n    from = 0;\n  }\n  if (from >= length) {\n    return;\n  }\n  return array[from + Math.floor(Math.random() * (length - from))];\n};\n\n/**\n * Error message for connection being disconnected\n */\nexports.CONNECTION_CLOSED_ERROR_MSG = 'Connection is closed.';\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/commander.js":"'use strict';\n\nvar _ = require('lodash');\nvar Command = require('./command');\nvar Script = require('./script');\nvar Promise = require('bluebird');\n\nvar DROP_BUFFER_SUPPORT_ERROR = '*Buffer methods are not available ' +\n  'because \"dropBufferSupport\" option is enabled.' +\n  'Refer to https://github.com/luin/ioredis/wiki/Improve-Performance for more details.';\n\n/**\n * Commander\n *\n * This is the base class of Redis, Redis.Cluster and Pipeline\n *\n * @param {boolean} [options.showFriendlyErrorStack=false] - Whether to show a friendly error stack.\n * Will decrease the performance significantly.\n * @constructor\n */\nfunction Commander() {\n  this.options = _.defaults({}, this.options || {}, {\n    showFriendlyErrorStack: false\n  });\n  this.scriptsSet = {};\n}\n\nvar commands = _.difference(require('redis-commands').list, ['monitor']);\ncommands.push('sentinel');\n\n/**\n * Return supported builtin commands\n *\n * @return {string[]} command list\n * @public\n */\nCommander.prototype.getBuiltinCommands = function () {\n  return _.clone(commands);\n};\n\n/**\n * Create a builtin command\n *\n * @param {string} commandName - command name\n * @return {object} functions\n * @public\n */\nCommander.prototype.createBuiltinCommand = function (commandName) {\n  return {\n    string: generateFunction(commandName, 'utf8'),\n    buffer: generateFunction(commandName, null)\n  };\n};\n\n_.forEach(commands, function (commandName) {\n  Commander.prototype[commandName] = generateFunction(commandName, 'utf8');\n  Commander.prototype[commandName + 'Buffer'] = generateFunction(commandName, null);\n});\n\nCommander.prototype.call = generateFunction('utf8');\nCommander.prototype.callBuffer = generateFunction(null);\nCommander.prototype.send_command = Commander.prototype.call;\n\n/**\n * Define a custom command using lua script\n *\n * @param {string} name - the command name\n * @param {object} definition\n * @param {string} definition.lua - the lua code\n * @param {number} [definition.numberOfKeys=null] - the number of keys.\n * If omit, you have to pass the number of keys as the first argument every time you invoke the command\n */\nCommander.prototype.defineCommand = function (name, definition) {\n  var script = new Script(definition.lua, definition.numberOfKeys,\n                          this.options.keyPrefix);\n  this.scriptsSet[name] = script;\n  this[name] = generateScriptingFunction(script, 'utf8');\n  this[name + 'Buffer'] = generateScriptingFunction(script, null);\n};\n\n/**\n * Send a command\n *\n * @abstract\n * @public\n */\nCommander.prototype.sendCommand = function () {};\n\nfunction generateFunction(_commandName, _encoding) {\n  if (typeof _encoding === 'undefined') {\n    _encoding = _commandName;\n    _commandName = null;\n  }\n  return function () {\n    var firstArgIndex = 0;\n    var commandName = _commandName;\n    if (commandName === null) {\n      commandName = arguments[0];\n      firstArgIndex = 1;\n    }\n    var length = arguments.length;\n    var lastArgIndex = length - 1;\n    var callback = arguments[lastArgIndex];\n    if (typeof callback !== 'function') {\n      callback = undefined;\n    } else {\n      length = lastArgIndex;\n    }\n    var args = new Array(length - firstArgIndex);\n    for (var i = firstArgIndex; i < length; ++i) {\n      args[i - firstArgIndex] = arguments[i];\n    }\n\n    var options;\n    if (this.options.dropBufferSupport) {\n      if (!_encoding) {\n        return Promise.reject(new Error(DROP_BUFFER_SUPPORT_ERROR)).nodeify(callback);\n      }\n      options = { replyEncoding: null };\n    } else {\n      options = { replyEncoding: _encoding };\n    }\n\n    if (this.options.showFriendlyErrorStack) {\n      options.errorStack = new Error().stack;\n    }\n    if (this.options.keyPrefix) {\n      options.keyPrefix = this.options.keyPrefix;\n    }\n\n    return this.sendCommand(new Command(commandName, args, options, callback));\n  };\n}\n\nfunction generateScriptingFunction(_script, _encoding) {\n  return function () {\n    var length = arguments.length;\n    var lastArgIndex = length - 1;\n    var callback = arguments[lastArgIndex];\n    if (typeof callback !== 'function') {\n      callback = undefined;\n    } else {\n      length = lastArgIndex;\n    }\n    var args = new Array(length);\n    for (var i = 0; i < length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var options;\n    if (this.options.dropBufferSupport) {\n      if (!_encoding) {\n        return Promise.reject(new Error(DROP_BUFFER_SUPPORT_ERROR)).nodeify(callback);\n      }\n      options = { replyEncoding: null };\n    } else {\n      options = { replyEncoding: _encoding };\n    }\n\n    if (this.options.showFriendlyErrorStack) {\n      options.errorStack = new Error().stack;\n    }\n\n    return _script.execute(this, args, options, callback);\n  };\n}\n\nmodule.exports = Commander;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/script.js":"'use strict';\n\nvar Command = require('./command');\nvar crypto = require('crypto');\nvar Promise = require('bluebird');\n\nfunction Script(lua, numberOfKeys, keyPrefix) {\n  this.lua = lua;\n  this.sha = crypto.createHash('sha1').update(this.lua).digest('hex');\n  this.numberOfKeys = typeof numberOfKeys === 'number' ? numberOfKeys : null;\n  this.keyPrefix = keyPrefix ? keyPrefix : '';\n}\n\nScript.prototype.execute = function (container, args, options, callback) {\n  if (typeof this.numberOfKeys === 'number') {\n    args.unshift(this.numberOfKeys);\n  }\n  if (this.keyPrefix) {\n    options.keyPrefix = this.keyPrefix;\n  }\n\n  var evalsha = new Command('evalsha', [this.sha].concat(args), options);\n  evalsha.isCustomCommand = true;\n  var result = container.sendCommand(evalsha);\n  if (result instanceof Promise) {\n    var _this = this;\n    return result.catch(function (err) {\n      if (err.toString().indexOf('NOSCRIPT') === -1) {\n        throw err;\n      }\n      return container.sendCommand(new Command('eval', [_this.lua].concat(args), options));\n    }).nodeify(callback);\n  }\n\n  // result is not a Promise--probably returned from a pipeline chain; however,\n  // we still need the callback to fire when the script is evaluated\n  evalsha.promise.nodeify(callback);\n\n  return result;\n};\n\nmodule.exports = Script;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/redis/event_handler.js":"'use strict';\n\nvar debug = require('debug')('ioredis:connection');\nvar Command = require('../command');\nvar utils = require('../utils');\nvar _ = require('lodash');\n\nexports.connectHandler = function (self) {\n  return function () {\n    self.setStatus('connect');\n\n    self.resetCommandQueue();\n\n    // AUTH command should be processed before any other commands\n    var flushed = false;\n    if (self.condition.auth) {\n      self.auth(self.condition.auth, function (err) {\n        if (err) {\n          if (err.message.indexOf('no password is set') === -1) {\n            flushed = true;\n            self.flushQueue(err);\n            self.silentEmit('error', err);\n            self.disconnect(true);\n          } else {\n            console.warn('[WARN] Redis server does not require a password, but a password was supplied.');\n          }\n        }\n      });\n    }\n\n    if (self.condition.select) {\n      self.select(self.condition.select);\n    }\n\n    if (!self.options.enableReadyCheck) {\n      exports.readyHandler(self)();\n    }\n\n    self.initParser();\n\n    if (self.options.enableReadyCheck) {\n      self._readyCheck(function (err, info) {\n        if (err) {\n          if (!flushed) {\n            self.flushQueue(new Error('Ready check failed: ' + err.message));\n            self.silentEmit('error', err);\n            self.disconnect(true);\n          }\n        } else {\n          self.serverInfo = info;\n          if (self.connector.check(info)) {\n            exports.readyHandler(self)();\n          } else {\n            self.disconnect(true);\n          }\n        }\n      });\n    }\n  };\n};\n\nexports.closeHandler = function (self) {\n  return function () {\n    self.setStatus('close');\n\n    if (!self.prevCondition) {\n      self.prevCondition = self.condition;\n    }\n    if (self.commandQueue.length) {\n      self.prevCommandQueue = self.commandQueue;\n    }\n\n    if (self.manuallyClosing) {\n      self.manuallyClosing = false;\n      debug('skip reconnecting since the connection is manually closed.');\n      return close();\n    }\n\n    if (typeof self.options.retryStrategy !== 'function') {\n      debug('skip reconnecting because `retryStrategy` is not a function');\n      return close();\n    }\n    var retryDelay = self.options.retryStrategy(++self.retryAttempts);\n\n    if (typeof retryDelay !== 'number') {\n      debug('skip reconnecting because `retryStrategy` doesn\\'t return a number');\n      return close();\n    }\n\n    debug('reconnect in %sms', retryDelay);\n\n    self.setStatus('reconnecting', retryDelay);\n    self.reconnectTimeout = setTimeout(function () {\n      self.reconnectTimeout = null;\n      self.connect().catch(_.noop);\n    }, retryDelay);\n  };\n\n  function close() {\n    self.setStatus('end');\n    self.flushQueue(new Error(utils.CONNECTION_CLOSED_ERROR_MSG));\n  }\n};\n\nexports.dataHandler = function (self) {\n  return function (data) {\n    self.replyParser.execute(data);\n  };\n};\n\nexports.errorHandler = function (self) {\n  return function (error) {\n    debug('error: %s', error);\n    self.silentEmit('error', error);\n  };\n};\n\nexports.readyHandler = function (self) {\n  return function () {\n    self.setStatus('ready');\n    self.retryAttempts = 0;\n\n    if (self.options.monitor) {\n      self.call('monitor');\n      var sendCommand = self.sendCommand;\n      self.sendCommand = function (command) {\n        if (Command.checkFlag('VALID_IN_MONITOR_MODE', command.name)) {\n          return sendCommand.call(self, command);\n        }\n        command.reject(new Error('Connection is in monitoring mode, can\\'t process commands.'));\n        return command.promise;\n      };\n      self.once('close', function () {\n        delete self.sendCommand;\n      });\n      self.setStatus('monitoring');\n      return;\n    }\n    var item;\n    var finalSelect = self.prevCondition ? self.prevCondition.select : self.condition.select;\n\n    if (self.options.connectionName) {\n      debug('set the connection name [%s]', self.options.connectionName);\n      self.client('setname', self.options.connectionName);\n    }\n\n    if (self.options.readOnly) {\n      debug('set the connection to readonly mode');\n      self.readonly().catch(_.noop);\n    }\n\n    if (self.prevCondition) {\n      var condition = self.prevCondition;\n      self.prevCondition = null;\n      if (condition.subscriber && self.options.autoResubscribe) {\n        // We re-select the previous db first since\n        // `SELECT` command is not valid in sub mode.\n        if (self.condition.select !== finalSelect) {\n          debug('connect to db [%d]', finalSelect);\n          self.select(finalSelect);\n        }\n        var subscribeChannels = condition.subscriber.channels('subscribe');\n        if (subscribeChannels.length) {\n          debug('subscribe %d channels', subscribeChannels.length);\n          self.subscribe(subscribeChannels);\n        }\n        var psubscribeChannels = condition.subscriber.channels('psubscribe');\n        if (psubscribeChannels.length) {\n          debug('psubscribe %d channels', psubscribeChannels.length);\n          self.psubscribe(psubscribeChannels);\n        }\n      }\n    }\n\n    if (self.prevCommandQueue) {\n      if (self.options.autoResendUnfulfilledCommands) {\n        debug('resend %d unfulfilled commands', self.prevCommandQueue.length);\n        while (self.prevCommandQueue.length > 0) {\n          item = self.prevCommandQueue.shift();\n          if (item.select !== self.condition.select && item.command.name !== 'select') {\n            self.select(item.select);\n          }\n          self.sendCommand(item.command, item.stream);\n        }\n      } else {\n        self.prevCommandQueue = null;\n      }\n    }\n\n    if (self.offlineQueue.length) {\n      debug('send %d commands in offline queue', self.offlineQueue.length);\n      var offlineQueue = self.offlineQueue;\n      self.resetOfflineQueue();\n      while (offlineQueue.length > 0) {\n        item = offlineQueue.shift();\n        if (item.select !== self.condition.select && item.command.name !== 'select') {\n          self.select(item.select);\n        }\n        self.sendCommand(item.command, item.stream);\n      }\n    }\n\n    if (self.condition.select !== finalSelect) {\n      debug('connect to db [%d]', finalSelect);\n      self.select(finalSelect);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/connectors/connector.js":"'use strict';\n\nvar _ = require('lodash');\nvar net = require('net');\nvar tls = require('tls');\nvar utils = require('../utils');\n\nfunction Connector(options) {\n  this.options = options;\n}\n\nConnector.prototype.check = function () {\n  return true;\n};\n\nConnector.prototype.disconnect = function () {\n  this.connecting = false;\n  if (this.stream) {\n    this.stream.end();\n  }\n};\n\nConnector.prototype.connect = function (callback) {\n  this.connecting = true;\n  var connectionOptions;\n  if (this.options.path) {\n    connectionOptions = _.pick(this.options, ['path']);\n  } else {\n    connectionOptions = _.pick(this.options, ['port', 'host', 'family']);\n  }\n  if (this.options.tls) {\n    _.assign(connectionOptions, this.options.tls);\n  }\n\n  var _this = this;\n  process.nextTick(function () {\n    if (!_this.connecting) {\n      callback(new Error(utils.CONNECTION_CLOSED_ERROR_MSG));\n      return;\n    }\n    var stream;\n\n    try {\n      if (_this.options.tls) {\n        stream = tls.connect(connectionOptions);\n      } else {\n        stream = net.createConnection(connectionOptions);\n      }\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    _this.stream = stream;\n    callback(null, stream);\n  });\n};\n\nmodule.exports = Connector;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/connectors/sentinel_connector.js":"'use strict';\n\nvar _ = require('lodash');\nvar util = require('util');\nvar net = require('net');\nvar utils = require('../utils');\nvar Connector = require('./connector');\nvar debug = require('debug')('ioredis:SentinelConnector');\nvar Redis;\n\nfunction SentinelConnector(options) {\n  Connector.call(this, options);\n  if (this.options.sentinels.length === 0) {\n    throw new Error('Requires at least one sentinel to connect to.');\n  }\n  if (!this.options.name) {\n    throw new Error('Requires the name of master.');\n  }\n}\n\nutil.inherits(SentinelConnector, Connector);\n\nSentinelConnector.prototype.check = function (info) {\n  if (info.role && this.options.role !== info.role) {\n    debug('role invalid, expected %s, but got %s', this.options.role, info.role);\n    return false;\n  }\n  return true;\n};\n\nSentinelConnector.prototype.connect = function (callback) {\n  this.connecting = true;\n  this.retryAttempts = 0;\n\n  if (typeof this.currentPoint !== 'number') {\n    this.currentPoint = -1;\n  }\n  if (!Array.isArray(this.sentinels)) {\n    this.sentinels = this.options.sentinels;\n  }\n\n  var _this = this;\n  var lastError;\n  connectToNext();\n\n  function connectToNext() {\n    _this.currentPoint += 1;\n    if (_this.currentPoint === _this.sentinels.length) {\n      _this.currentPoint = -1;\n\n      var retryDelay;\n      if (typeof _this.options.sentinelRetryStrategy === 'function') {\n        retryDelay = _this.options.sentinelRetryStrategy(++_this.retryAttempts);\n      }\n      if (typeof retryDelay !== 'number') {\n        debug('All sentinels are unreachable and retry is disabled, emitting error...');\n        var error = 'All sentinels are unreachable.';\n        if (lastError) {\n          error += ' Last error: ' + lastError.message;\n        }\n        return callback(new Error(error));\n      }\n      debug('All sentinels are unreachable. Retrying from scratch after %d', retryDelay);\n      setTimeout(connectToNext, retryDelay);\n      return;\n    }\n\n    var endpoint = _this.sentinels[_this.currentPoint];\n    _this.resolve(endpoint, function (err, resolved) {\n      if (!_this.connecting) {\n        callback(new Error(utils.CONNECTION_CLOSED_ERROR_MSG));\n        return;\n      }\n      if (resolved) {\n        _this.stream = net.createConnection(resolved);\n        callback(null, _this.stream);\n      } else if (err) {\n        debug('failed to connect to sentinel %s:%s because %s', endpoint.host, endpoint.port, err);\n        lastError = err;\n        connectToNext();\n      } else {\n        debug('connected to sentinel %s:%s successfully, but got a invalid reply: %s',\n          endpoint.host, endpoint.port, resolved);\n        connectToNext();\n      }\n    });\n  }\n};\n\nSentinelConnector.prototype.updateSentinels = function (client, callback) {\n  var _this = this;\n  client.sentinel('sentinels', this.options.name, function (err, result) {\n    if (err) {\n      client.disconnect();\n      return callback(err);\n    }\n    if (Array.isArray(result)) {\n      for (var i = 0; i < result.length; ++i) {\n        var sentinel = utils.packObject(result[i]);\n        var flags = sentinel.flags ? sentinel.flags.split(',') : [];\n        if (flags.indexOf('disconnected') === -1 && sentinel.ip && sentinel.port) {\n          var endpoint = { host: sentinel.ip, port: parseInt(sentinel.port, 10) };\n          var isDuplicate = _this.sentinels.some(_.bind(isSentinelEql, null, endpoint));\n          if (!isDuplicate) {\n            debug('adding sentinel %s:%s', endpoint.host, endpoint.port);\n            _this.sentinels.push(endpoint);\n          }\n        }\n      }\n      debug('sentinels', _this.sentinels);\n    }\n    callback(null);\n  });\n};\n\nSentinelConnector.prototype.resolveMaster = function (client, callback) {\n  var _this = this;\n  client.sentinel('get-master-addr-by-name', this.options.name, function (err, result) {\n    if (err) {\n      client.disconnect();\n      return callback(err);\n    }\n    _this.updateSentinels(client, function (err) {\n      client.disconnect();\n      if (err) {\n        return callback(err);\n      }\n      callback(null, Array.isArray(result) ? { host: result[0], port: result[1] } : null);\n    });\n  });\n};\n\nSentinelConnector.prototype.resolveSlave = function (client, callback) {\n  var _this = this;\n  client.sentinel('slaves', this.options.name, function (err, result) {\n    client.disconnect();\n    if (err) {\n      return callback(err);\n    }\n    var selectedSlave;\n    if (Array.isArray(result)) {\n      var availableSlaves = [];\n      for (var i = 0; i < result.length; ++i) {\n        var slave = utils.packObject(result[i]);\n        if (slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/)) {\n          availableSlaves.push(slave);\n        }\n      }\n      // allow the options to prefer particular slave(s)\n      if (_this.options.preferredSlaves) {\n        var preferredSlaves = _this.options.preferredSlaves;\n        switch (typeof preferredSlaves) {\n        case 'function':\n          // use function from options to filter preferred slave\n          selectedSlave = _this.options.preferredSlaves(availableSlaves);\n          break;\n        case 'object':\n          if (!Array.isArray(preferredSlaves)) {\n            preferredSlaves = [preferredSlaves];\n          } else {\n            // sort by priority\n            preferredSlaves.sort(function (a, b) {\n              // default the priority to 1\n              if (!a.prio) {\n                a.prio = 1;\n              }\n              if (!b.prio) {\n                b.prio = 1;\n              }\n\n              // lowest priority first\n              if (a.prio < b.prio) {\n                return -1;\n              }\n              if (a.prio > b.prio) {\n                return 1;\n              }\n              return 0;\n            });\n          }\n          // loop over preferred slaves and return the first match\n          for (var p = 0; p < preferredSlaves.length; p++) {\n            for (var a = 0; a < availableSlaves.length; a++) {\n              if (availableSlaves[a].ip === preferredSlaves[p].ip) {\n                if (availableSlaves[a].port === preferredSlaves[p].port) {\n                  selectedSlave = availableSlaves[a];\n                  break;\n                }\n              }\n            }\n            if (selectedSlave) {\n              break;\n            }\n          }\n          // if none of the preferred slaves are available, a random available slave is returned\n          break;\n        }\n      }\n      if (!selectedSlave) {\n        // get a random available slave\n        selectedSlave = _.sample(availableSlaves);\n      }\n    }\n    callback(null, selectedSlave ? { host: selectedSlave.ip, port: selectedSlave.port } : null);\n  });\n};\n\nSentinelConnector.prototype.resolve = function (endpoint, callback) {\n  if (typeof Redis === 'undefined') {\n    Redis = require('../redis');\n  }\n  var client = new Redis({\n    port: endpoint.port,\n    host: endpoint.host,\n    retryStrategy: null,\n    enableReadyCheck: false,\n    connectTimeout: this.options.connectTimeout,\n    dropBufferSupport: true\n  });\n\n  // ignore the errors since resolve* methods will handle them\n  client.on('error', noop);\n\n  if (this.options.role === 'slave') {\n    this.resolveSlave(client, callback);\n  } else {\n    this.resolveMaster(client, callback);\n  }\n};\n\nfunction noop() {}\n\nfunction isSentinelEql(a, b) {\n  return ((a.host || '127.0.0.1') === (b.host || '127.0.0.1')) &&\n    ((a.port || 6379) === (b.port || 6379));\n}\n\nmodule.exports = SentinelConnector;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/scan_stream.js":"'use strict';\n\nvar Readable = require('stream').Readable;\nvar util = require('util');\n\n/**\n * Convenient class to convert the process of scaning keys to a readable stream.\n *\n * @constructor\n * @private\n */\nfunction ScanStream(opt) {\n  Readable.call(this, opt);\n  this._redisCursor = '0';\n  this.opt = opt;\n}\n\nutil.inherits(ScanStream, Readable);\n\nScanStream.prototype._read = function () {\n  if (this._redisDrained) {\n    this.push(null);\n    return;\n  }\n  var args = [this._redisCursor];\n  if (this.opt.key) {\n    args.unshift(this.opt.key);\n  }\n  if (this.opt.match) {\n    args.push('MATCH', this.opt.match);\n  }\n  if (this.opt.count) {\n    args.push('COUNT', this.opt.count);\n  }\n  var _this = this;\n  this.opt.redis[this.opt.command](args, function (err, res) {\n    if (err) {\n      _this.emit('error', err);\n      return;\n    }\n    _this._redisCursor = (res[0] instanceof Buffer) ? res[0].toString() : res[0];\n    if (_this._redisCursor === '0') {\n      _this._redisDrained = true;\n    }\n    _this.push(res[1]);\n  });\n};\n\nScanStream.prototype.close = function () {\n  this._redisDrained = true;\n};\n\nmodule.exports = ScanStream;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/transaction.js":"'use strict';\n\nvar Pipeline = require('./pipeline');\nvar utils = require('./utils');\n\nexports.addTransactionSupport = function (redis) {\n  redis.pipeline = function (commands) {\n    var pipeline = new Pipeline(this);\n    if (Array.isArray(commands)) {\n      pipeline.addBatch(commands);\n    }\n    return pipeline;\n  };\n\n  var multi = redis.multi;\n  redis.multi = function (commands, options) {\n    if (typeof options === 'undefined' && !Array.isArray(commands)) {\n      options = commands;\n      commands = null;\n    }\n    if (options && options.pipeline === false) {\n      return multi.call(this);\n    }\n    var pipeline = new Pipeline(this);\n    pipeline.multi();\n    if (Array.isArray(commands)) {\n      pipeline.addBatch(commands);\n    }\n    var exec = pipeline.exec;\n    pipeline.exec = function (callback) {\n      if (this._transactions > 0) {\n        exec.call(pipeline);\n      }\n      var promise = exec.call(pipeline);\n      return promise.then(function (result) {\n        var execResult = result[result.length - 1];\n        if (execResult[0]) {\n          execResult[0].previousErrors = [];\n          for (var i = 0; i < result.length - 1; ++i) {\n            if (result[i][0]) {\n              execResult[0].previousErrors.push(result[i][0]);\n            }\n          }\n          throw execResult[0];\n        }\n        return utils.wrapMultiResult(execResult[1]);\n      }).nodeify(callback);\n    };\n\n    var execBuffer = pipeline.execBuffer;\n    pipeline.execBuffer = function (callback) {\n      if (this._transactions > 0) {\n        execBuffer.call(pipeline);\n      }\n      return pipeline.exec(callback);\n    };\n    return pipeline;\n  };\n\n  var exec = redis.exec;\n  redis.exec = function (callback) {\n    return exec.call(this).then(function (results) {\n      if (Array.isArray(results)) {\n        results = utils.wrapMultiResult(results);\n      }\n      return results;\n    }).nodeify(callback);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/pipeline.js":"'use strict';\nvar _ = require('lodash');\nvar Commander = require('./commander');\nvar Command = require('./command');\nvar fbuffer = require('flexbuffer');\nvar Promise = require('bluebird');\nvar util = require('util');\nvar commands = require('redis-commands');\nvar calculateSlot = require('cluster-key-slot');\n\nfunction Pipeline(redis) {\n  Commander.call(this);\n\n  this.redis = redis;\n  this.isCluster = this.redis.constructor.name === 'Cluster';\n  this.options = redis.options;\n  this._queue = [];\n  this._result = [];\n  this._transactions = 0;\n  this._shaToScript = {};\n\n  var _this = this;\n  _.keys(redis.scriptsSet).forEach(function (name) {\n    var script = redis.scriptsSet[name];\n    _this._shaToScript[script.sha] = script;\n    _this[name] = redis[name];\n    _this[name + 'Buffer'] = redis[name + 'Buffer'];\n  });\n\n  this.promise = new Promise(function (resolve, reject) {\n    _this.resolve = resolve;\n    _this.reject = reject;\n  });\n}\n\n_.assign(Pipeline.prototype, Commander.prototype);\n\nPipeline.prototype.fillResult = function (value, position) {\n  var i;\n  if (this._queue[position].name === 'exec' && Array.isArray(value[1])) {\n    var execLength = value[1].length;\n    for (i = 0; i < execLength; i++) {\n      if (value[1][i] instanceof Error) {\n        continue;\n      }\n      var cmd = this._queue[position - (execLength - i)];\n      try {\n        value[1][i] = cmd.transformReply(value[1][i]);\n      } catch (err) {\n        value[1][i] = err;\n      }\n    }\n  }\n  this._result[position] = value;\n\n  if (--this.replyPending) {\n    return;\n  }\n\n  if (this.isCluster) {\n    var retriable = true;\n    var commonError;\n    var inTransaction;\n    for (i = 0; i < this._result.length; ++i) {\n      var error = this._result[i][0];\n      var command = this._queue[i];\n      if (command.name === 'multi') {\n        inTransaction = true;\n      } else if (command.name === 'exec') {\n        inTransaction = false;\n      }\n      if (error) {\n        if (command.name === 'exec' && error.message === 'EXECABORT Transaction discarded because of previous errors.') {\n          continue;\n        }\n        if (!commonError) {\n          commonError = {\n            name: error.name,\n            message: error.message\n          };\n        } else if (commonError.name !== error.name || commonError.message !== error.message) {\n          retriable = false;\n          break;\n        }\n      } else if (!inTransaction) {\n        var isReadOnly = commands.exists(command.name) && commands.hasFlag(command.name, 'readonly');\n        if (!isReadOnly) {\n          retriable = false;\n          break;\n        }\n      }\n    }\n    if (commonError && retriable) {\n      var _this = this;\n      var errv = commonError.message.split(' ');\n      var queue = this._queue;\n      inTransaction = false;\n      this._queue = [];\n      for (i = 0; i < queue.length; ++i) {\n        if (errv[0] === 'ASK' && !inTransaction &&\n            queue[i].name !== 'asking' &&\n            (!queue[i - 1] || queue[i - 1].name !== 'asking')) {\n          var asking = new Command('asking');\n          asking.ignore = true;\n          this.sendCommand(asking);\n        }\n        queue[i].initPromise();\n        this.sendCommand(queue[i]);\n        if (queue[i].name === 'multi') {\n          inTransaction = true;\n        } else if (queue[i].name === 'exec') {\n          inTransaction = false;\n        }\n      }\n\n      var matched = true;\n      if (typeof this.leftRedirections === 'undefined') {\n        this.leftRedirections = {};\n      }\n      var exec = function () {\n        _this.exec();\n      };\n      this.redis.handleError(commonError, this.leftRedirections, {\n        moved: function (slot, key) {\n          _this.preferKey = key;\n          _this.redis.slots[errv[1]] = [key];\n          _this.redis.refreshSlotsCache();\n          _this.exec();\n        },\n        ask: function (slot, key) {\n          _this.preferKey = key;\n          _this.exec();\n        },\n        tryagain: exec,\n        clusterDown: exec,\n        connectionClosed: exec,\n        maxRedirections: function () {\n          matched = false;\n        },\n        defaults: function () {\n          matched = false;\n        }\n      });\n      if (matched) {\n        return;\n      }\n    }\n  }\n\n  var ignoredCount = 0;\n  for (i = 0; i < this._queue.length - ignoredCount; ++i) {\n    if (this._queue[i + ignoredCount].ignore) {\n      ignoredCount += 1;\n    }\n    this._result[i] = this._result[i + ignoredCount];\n  }\n  this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n};\n\nPipeline.prototype.sendCommand = function (command) {\n  var position = this._queue.length;\n\n  var _this = this;\n\n  command.promise.then(function (result) {\n    _this.fillResult([null, result], position);\n  }).catch(function (error) {\n    _this.fillResult([error], position);\n  });\n\n  this._queue.push(command);\n\n  return this;\n};\n\nPipeline.prototype.addBatch = function (commands) {\n  for (var i = 0; i < commands.length; ++i) {\n    var command = commands[i];\n    var commandName = command.shift();\n    this[commandName].apply(this, command);\n  }\n\n  return this;\n};\n\nvar multi = Pipeline.prototype.multi;\nPipeline.prototype.multi = function () {\n  this._transactions += 1;\n  return multi.apply(this, arguments);\n};\n\nvar execBuffer = Pipeline.prototype.execBuffer;\nvar exec = Pipeline.prototype.exec;\nPipeline.prototype.execBuffer = util.deprecate(function () {\n  if (this._transactions > 0) {\n    this._transactions -= 1;\n  }\n  return execBuffer.apply(this, arguments);\n}, 'Pipeline#execBuffer: Use Pipeline#exec instead');\n\nPipeline.prototype.exec = function (callback) {\n  if (this._transactions > 0) {\n    this._transactions -= 1;\n    return (this.options.dropBufferSupport ? exec : execBuffer).apply(this, arguments);\n  }\n  if (!this.nodeifiedPromise) {\n    this.nodeifiedPromise = true;\n    this.promise.nodeify(callback);\n  }\n  if (_.isEmpty(this._queue)) {\n    this.resolve([]);\n  }\n  var pipelineSlot, i;\n  if (this.isCluster) {\n    // List of the first key for each command\n    var sampleKeys = [];\n    for (i = 0; i < this._queue.length; i++) {\n      var keys = this._queue[i].getKeys();\n      if (keys.length) {\n        sampleKeys.push(keys[0]);\n      }\n    }\n\n    if (sampleKeys.length) {\n      pipelineSlot = calculateSlot.generateMulti(sampleKeys);\n      if (pipelineSlot < 0) {\n        this.reject(new Error('All keys in the pipeline should belong to the same slot'));\n        return this.promise;\n      }\n    } else {\n      // Send the pipeline to a random node\n      pipelineSlot = Math.random() * 16384 | 0;\n    }\n  }\n\n  // Check whether scripts exists\n  var scripts = [];\n  for (i = 0; i < this._queue.length; ++i) {\n    var item = this._queue[i];\n    if (this.isCluster && item.isCustomCommand) {\n      this.reject(new Error('Sending custom commands in pipeline is not supported in Cluster mode.'));\n      return this.promise;\n    }\n    if (item.name !== 'evalsha') {\n      continue;\n    }\n    var script = this._shaToScript[item.args[0]];\n    if (!script) {\n      continue;\n    }\n    scripts.push(script);\n  }\n\n  var _this = this;\n  if (!scripts.length) {\n    return execPipeline();\n  }\n\n  return this.redis.script('exists', scripts.map(function (item) {\n    return item.sha;\n  })).then(function (results) {\n    var pending = [];\n    for (var i = 0; i < results.length; ++i) {\n      if (!results[i]) {\n        pending.push(scripts[i]);\n      }\n    }\n    return Promise.all(pending.map(function (script) {\n      return _this.redis.script('load', script.lua);\n    }));\n  }).then(execPipeline);\n\n  function execPipeline() {\n    var data = '';\n    var writePending = _this.replyPending = _this._queue.length;\n\n    var node;\n    if (_this.isCluster) {\n      node = { slot: pipelineSlot, redis: _this.redis.connectionPool.nodes.all[_this.preferKey] };\n    }\n    var bufferMode = false;\n    var stream = {\n      write: function (writable) {\n        if (writable instanceof Buffer) {\n          bufferMode = true;\n        }\n        if (bufferMode) {\n          if (typeof data === 'string') {\n            var flexBuffer = new fbuffer.FlexBuffer(0);\n            flexBuffer.write(data);\n            data = flexBuffer;\n          }\n          data.write(writable);\n        } else {\n          data += writable;\n        }\n        if (!--writePending) {\n          if (bufferMode) {\n            data = data.getBuffer();\n          }\n          if (_this.isCluster) {\n            node.redis.stream.write(data);\n          } else {\n            _this.redis.stream.write(data);\n          }\n\n          // Reset writePending for resending\n          writePending = _this._queue.length;\n          data = '';\n          bufferMode = false;\n        }\n      }\n    };\n\n    for (var i = 0; i < _this._queue.length; ++i) {\n      _this.redis.sendCommand(_this._queue[i], stream, node);\n    }\n    return _this.promise;\n  }\n};\n\nmodule.exports = Pipeline;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/redis/parser.js":"'use strict';\n\nvar _ = require('lodash');\nvar Command = require('../command');\nvar SubscriptionSet = require('../subscription_set');\nvar debug = require('debug')('ioredis:reply');\nvar Parser = require('redis-parser');\nvar ReplyError = require('../reply_error');\n\n/**\n * Init the parser\n *\n * @method _initParser\n * @memberOf Redis#\n * @private\n */\nexports.initParser = function () {\n  var _this = this;\n\n  this.replyParser = new Parser({\n    name: this.options.parser,\n    stringNumbers: this.options.stringNumbers,\n    returnBuffers: !this.options.dropBufferSupport,\n    returnError: function (err) {\n      _this.returnError(new ReplyError(err.message));\n    },\n    returnReply: function (reply) {\n      _this.returnReply(reply);\n    },\n    returnFatalError: function (err) {\n      _this.flushQueue(err, { offlineQueue: false });\n      _this.silentEmit('error', new Error('Redis parser fatal error: ' + err.stack));\n      _this.disconnect(true);\n    }\n  });\n\n  if (this.replyParser.name === 'hiredis' && !this.options.dropBufferSupport) {\n    console.warn('[WARN] ioredis is using hiredis parser, however \"dropBufferSupport\" is disabled. ' +\n     'It\\'s highly recommended to enable this option. ' +\n     'Refer to https://github.com/luin/ioredis/wiki/Improve-Performance for more details.');\n  }\n};\n\nexports.returnError = function (err) {\n  var item = this.commandQueue.shift();\n\n  err.command = {\n    name: item.command.name,\n    args: item.command.args\n  };\n\n  var needReconnect = false;\n  if (this.options.reconnectOnError) {\n    needReconnect = this.options.reconnectOnError(err);\n  }\n\n  switch (needReconnect) {\n  case 1:\n  case true:\n    if (this.status !== 'reconnecting') {\n      this.disconnect(true);\n    }\n    item.command.reject(err);\n    break;\n  case 2:\n    if (this.status !== 'reconnecting') {\n      this.disconnect(true);\n    }\n    if (this.condition.select !== item.select && item.command.name !== 'select') {\n      this.select(item.select);\n    }\n    this.sendCommand(item.command);\n    break;\n  default:\n    item.command.reject(err);\n  }\n};\n\nvar sharedBuffers = {};\n_.forEach(['message', 'pmessage', 'subscribe', 'psubscribe', 'unsubscribe', 'punsubscribe'], function (str) {\n  sharedBuffers[str] = new Buffer(str);\n});\nexports.returnReply = function (reply) {\n  if (this.status === 'monitoring') {\n    // Valid commands in the monitoring mode are AUTH and MONITOR,\n    // both of which always reply with 'OK'.\n    var replyStr = reply.toString();\n\n    // If not the reply to AUTH & MONITOR\n    if (replyStr !== 'OK') {\n      // Since commands sent in the monitoring mode will trigger an exception,\n      // any replies we received in the monitoring mode should consider to be\n      // realtime monitor data instead of result of commands.\n      var len = replyStr.indexOf(' ');\n      var timestamp = replyStr.slice(0, len);\n      var argindex = replyStr.indexOf('\"');\n      var args = replyStr.slice(argindex + 1, -1).split('\" \"').map(function (elem) {\n        return elem.replace(/\\\\\"/g, '\"');\n      });\n      var dbAndSource = replyStr.slice(len + 2, argindex - 2).split(' ');\n      this.emit('monitor', timestamp, args, dbAndSource[1], dbAndSource[0]);\n      return;\n    }\n  }\n\n  var item, channel, count;\n  if (this.condition.subscriber) {\n    var replyType = Array.isArray(reply) ? reply[0].toString() : null;\n    debug('receive reply \"%s\" in subscriber mode', replyType);\n\n    switch (replyType) {\n    case 'message':\n      if (this.listeners('message').length > 0) {\n        this.emit('message', reply[1].toString(), reply[2].toString());\n      }\n      if (this.listeners('messageBuffer').length > 0) {\n        this.emit('messageBuffer', reply[1], reply[2]);\n      }\n      break;\n    case 'pmessage':\n      var pattern = reply[1].toString();\n      if (this.listeners('pmessage').length > 0) {\n        this.emit('pmessage', pattern, reply[2].toString(), reply[3].toString());\n      }\n      if (this.listeners('pmessageBuffer').length > 0) {\n        this.emit('pmessageBuffer', pattern, reply[2], reply[3]);\n      }\n      break;\n    case 'subscribe':\n    case 'psubscribe':\n      channel = reply[1].toString();\n      this.condition.subscriber.add(replyType, channel);\n      item = this.commandQueue.shift();\n      if (!fillSubCommand(item.command, reply[2])) {\n        this.commandQueue.unshift(item);\n      }\n      break;\n    case 'unsubscribe':\n    case 'punsubscribe':\n      channel = reply[1] ? reply[1].toString() : null;\n      if (channel) {\n        this.condition.subscriber.del(replyType, channel);\n      }\n      count = reply[2];\n      if (count === 0) {\n        this.condition.subscriber = false;\n      }\n      item = this.commandQueue.shift();\n      if (!fillUnsubCommand(item.command, count)) {\n        this.commandQueue.unshift(item);\n      }\n      break;\n    default:\n      item = this.commandQueue.shift();\n      item.command.resolve(reply);\n    }\n  } else {\n    item = this.commandQueue.shift();\n    if (!item) {\n      return this.emit('error',\n        new Error('Command queue state error. If you can reproduce this, please report it. Last reply: ' +\n          reply.toString()));\n    }\n    if (Command.checkFlag('ENTER_SUBSCRIBER_MODE', item.command.name)) {\n      this.condition.subscriber = new SubscriptionSet();\n      this.condition.subscriber.add(item.command.name, reply[1].toString());\n\n      if (!fillSubCommand(item.command, reply[2])) {\n        this.commandQueue.unshift(item);\n      }\n    } else if (Command.checkFlag('EXIT_SUBSCRIBER_MODE', item.command.name)) {\n      if (!fillUnsubCommand(item.command, reply[2])) {\n        this.commandQueue.unshift(item);\n      }\n    } else {\n      item.command.resolve(reply);\n    }\n  }\n\n  function fillSubCommand(command, count) {\n    if (typeof command.remainReplies === 'undefined') {\n      command.remainReplies = command.args.length;\n    }\n    if (--command.remainReplies === 0) {\n      command.resolve(count);\n      return true;\n    }\n    return false;\n  }\n\n  function fillUnsubCommand(command, count) {\n    if (typeof command.remainReplies === 'undefined') {\n      command.remainReplies = command.args.length;\n    }\n    if (command.remainReplies === 0) {\n      if (count === 0) {\n        command.resolve(reply[2]);\n        return true;\n      }\n      return false;\n    }\n    if (--command.remainReplies === 0) {\n      command.resolve(reply[2]);\n      return true;\n    }\n    return false;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/subscription_set.js":"'use strict';\n\n/**\n * Tiny class to simplify dealing with subscription set\n *\n * @constructor\n * @private\n */\nfunction SubscriptionSet() {\n  this.set = {\n    subscribe: {},\n    psubscribe: {}\n  };\n}\n\nSubscriptionSet.prototype.add = function (set, channel) {\n  this.set[mapSet(set)][channel] = true;\n};\n\nSubscriptionSet.prototype.del = function (set, channel) {\n  delete this.set[mapSet(set)][channel];\n};\n\nSubscriptionSet.prototype.channels = function (set) {\n  return Object.keys(this.set[mapSet(set)]);\n};\n\nSubscriptionSet.prototype.isEmpty = function () {\n  return this.channels('subscribe').length === 0 && this.channels('psubscribe').length === 0;\n};\n\nfunction mapSet(set) {\n  if (set === 'unsubscribe') {\n    return 'subscribe';\n  }\n  if (set === 'punsubscribe') {\n    return 'psubscribe';\n  }\n  return set;\n}\n\nmodule.exports = SubscriptionSet;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/reply_error.js":"'use strict';\n\nmodule.exports = function ReplyError(message) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n};\n\nrequire('util').inherits(module.exports, Error);\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/cluster/index.js":"'use strict';\n\nvar Promise = require('bluebird');\nvar Deque = require('double-ended-queue');\nvar Redis = require('../redis');\nvar utils = require('../utils');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar debug = require('debug')('ioredis:cluster');\nvar _ = require('lodash');\nvar ScanStream = require('../scan_stream');\nvar Commander = require('../commander');\nvar Command = require('../command');\nvar commands = require('redis-commands');\nvar ConnectionPool = require('./connection_pool');\nvar DelayQueue = require('./delay_queue');\n\n/**\n * Creates a Redis Cluster instance\n *\n * @constructor\n * @param {Object[]} startupNodes - An array of nodes in the cluster, [{ port: number, host: string }]\n * @param {Object} options\n * @param {function} [options.clusterRetryStrategy] - See \"Quick Start\" section\n * @param {boolean} [options.enableOfflineQueue=true] - See Redis class\n * @param {boolean} [options.enableReadyCheck=true] - When enabled, ioredis only emits \"ready\" event when `CLUSTER INFO`\n * command reporting the cluster is ready for handling commands.\n * @param {string} [options.scaleReads=master] - Scale reads to the node with the specified role.\n * Available values are \"master\", \"slave\" and \"all\".\n * @param {number} [options.maxRedirections=16] - When a MOVED or ASK error is received, client will redirect the\n * command to another node. This option limits the max redirections allowed to send a command.\n * @param {number} [options.retryDelayOnFailover=100] - When an error is received when sending a command(e.g.\n * \"Connection is closed.\" when the target Redis node is down),\n * @param {number} [options.retryDelayOnClusterDown=100] - When a CLUSTERDOWN error is received, client will retry\n * if `retryDelayOnClusterDown` is valid delay time.\n * @param {number} [options.retryDelayOnTryAgain=100] - When a TRYAGAIN error is received, client will retry\n * if `retryDelayOnTryAgain` is valid delay time.\n * @param {Object} [options.redisOptions] - Passed to the constructor of `Redis`.\n * @extends [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * @extends Commander\n */\nfunction Cluster(startupNodes, options) {\n  EventEmitter.call(this);\n  Commander.call(this);\n\n  this.options = _.defaults(this.options, options, Cluster.defaultOptions);\n\n  // validate options\n  if (typeof this.options.scaleReads !== 'function' &&\n      ['all', 'master', 'slave'].indexOf(this.options.scaleReads) === -1) {\n    throw new Error('Invalid option scaleReads \"' + this.options.scaleReads +\n      '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n  }\n\n  this.connectionPool = new ConnectionPool(this.options.redisOptions);\n  this.startupNodes = startupNodes;\n\n  var _this = this;\n  this.connectionPool.on('-node', function (redis) {\n    if (_this.status !== 'disconnecting' && _this.subscriber === redis) {\n      _this.selectSubscriber();\n    }\n    _this.emit('-node', redis);\n  });\n  this.connectionPool.on('+node', function (redis) {\n    _this.emit('+node', redis);\n  });\n  this.connectionPool.on('drain', function () {\n    _this.setStatus('close');\n  });\n  this.connectionPool.on('nodeError', function (error) {\n    _this.emit('node error', error);\n  });\n\n  this.slots = [];\n  this.retryAttempts = 0;\n\n  this.resetOfflineQueue();\n  this.delayQueue = new DelayQueue();\n\n  this.subscriber = null;\n\n  if (this.options.lazyConnect) {\n    this.setStatus('wait');\n  } else {\n    this.connect().catch(_.noop);\n  }\n}\n\n/**\n * Default options\n *\n * @var defaultOptions\n * @protected\n */\nCluster.defaultOptions = {\n  clusterRetryStrategy: function (times) {\n    return Math.min(100 + times * 2, 2000);\n  },\n  enableOfflineQueue: true,\n  enableReadyCheck: true,\n  scaleReads: 'master',\n  maxRedirections: 16,\n  retryDelayOnFailover: 100,\n  retryDelayOnClusterDown: 100,\n  retryDelayOnTryAgain: 100\n};\n\nutil.inherits(Cluster, EventEmitter);\n_.assign(Cluster.prototype, Commander.prototype);\n\nCluster.prototype.resetOfflineQueue = function () {\n  this.offlineQueue = new Deque();\n};\n\n/**\n * Connect to a cluster\n *\n * @return {Promise}\n * @public\n */\nCluster.prototype.connect = function () {\n  function readyHandler() {\n    this.setStatus('ready');\n    this.retryAttempts = 0;\n    this.executeOfflineCommands();\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (this.status === 'connecting' || this.status === 'connect' || this.status === 'ready') {\n      reject(new Error('Redis is already connecting/connected'));\n      return;\n    }\n    this.setStatus('connecting');\n\n    if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n      throw new Error('`startupNodes` should contain at least one node.');\n    }\n\n    this.connectionPool.reset(this.startupNodes);\n\n    var closeListener;\n    var refreshListener = function () {\n      this.removeListener('close', closeListener);\n      this.manuallyClosing = false;\n      this.setStatus('connect');\n      if (this.options.enableReadyCheck) {\n        this._readyCheck(function (err, fail) {\n          if (err || fail) {\n            this.disconnect(true);\n          } else {\n            readyHandler.call(this);\n          }\n        }.bind(this));\n      } else {\n        readyHandler.call(this);\n      }\n      resolve();\n    };\n\n    closeListener = function () {\n      this.removeListener('refresh', refreshListener);\n      reject(new Error('None of startup nodes is available'));\n    };\n\n    this.once('refresh', refreshListener);\n    this.once('close', closeListener);\n    this.once('close', this._handleCloseEvent.bind(this));\n\n    this.refreshSlotsCache(function (err) {\n      if (err && err.message === 'Failed to refresh slots cache.') {\n        Redis.prototype.silentEmit.call(this, 'error', err);\n        this.connectionPool.reset([]);\n      }\n    }.bind(this));\n    this.selectSubscriber();\n  }.bind(this));\n};\n\n/**\n * Called when closed to check whether a reconnection should be made\n * @private\n */\nCluster.prototype._handleCloseEvent = function () {\n  var retryDelay;\n  if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === 'function') {\n    retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts);\n  }\n  if (typeof retryDelay === 'number') {\n    this.setStatus('reconnecting');\n    this.reconnectTimeout = setTimeout(function () {\n      this.reconnectTimeout = null;\n      debug('Cluster is disconnected. Retrying after %dms', retryDelay);\n      this.connect().catch(_.noop);\n    }.bind(this), retryDelay);\n  } else {\n    this.setStatus('end');\n    this.flushQueue(new Error('None of startup nodes is available'));\n  }\n};\n\n/**\n * Disconnect from every node in the cluster.\n *\n * @public\n */\nCluster.prototype.disconnect = function (reconnect) {\n  var status = this.status;\n  this.setStatus('disconnecting');\n\n  if (!reconnect) {\n    this.manuallyClosing = true;\n  }\n  if (this.reconnectTimeout) {\n    clearTimeout(this.reconnectTimeout);\n    this.reconnectTimeout = null;\n  }\n\n  if (status === 'wait') {\n    this.setStatus('close');\n    this._handleCloseEvent();\n  } else {\n    this.connectionPool.reset([]);\n  }\n};\n\n/**\n * Quit the cluster gracefully.\n *\n * @param {function} callback\n * @return {Promise} return 'OK' if successfully\n * @public\n */\nCluster.prototype.quit = function (callback) {\n  var status = this.status;\n  this.setStatus('disconnecting');\n\n  this.manuallyClosing = true;\n\n  if (this.reconnectTimeout) {\n    clearTimeout(this.reconnectTimeout);\n    this.reconnectTimeout = null;\n  }\n  if (status === 'wait') {\n    var ret = Promise.resolve('OK').nodeify(callback);\n\n    // use setImmediate to make sure \"close\" event\n    // being emitted after quit() is returned\n    setImmediate(function () {\n      this.setStatus('close');\n      this._handleCloseEvent();\n    }.bind(this));\n\n    return ret;\n  }\n  return Promise.all(this.nodes().map(function (node) {\n    return node.quit();\n  })).then(function () {\n    return 'OK';\n  }).nodeify(callback);\n};\n\n/**\n * Get nodes with the specified role\n *\n * @param {string} [role=all] - role, \"master\", \"slave\" or \"all\"\n * @return {Redis[]} array of nodes\n * @public\n */\nCluster.prototype.nodes = function (role) {\n  role = role || 'all';\n  if (role !== 'all' && role !== 'master' && role !== 'slave') {\n    throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n  }\n  return _.values(this.connectionPool.nodes[role]);\n};\n\n/**\n * Select a subscriber from the cluster\n *\n * @private\n */\nCluster.prototype.selectSubscriber = function () {\n  this.subscriber = _.sample(this.nodes());\n  if (!this.subscriber) {\n    return;\n  }\n  // Re-subscribe previous channels\n  var previousChannels = { subscribe: [], psubscribe: [] };\n  if (this.lastActiveSubscriber && this.lastActiveSubscriber.prevCondition) {\n    var subscriber = this.lastActiveSubscriber.prevCondition.subscriber;\n    if (subscriber) {\n      previousChannels.subscribe = subscriber.channels('subscribe');\n      previousChannels.psubscribe = subscriber.channels('psubscribe');\n    }\n  }\n  var _this = this;\n  if (previousChannels.subscribe.length || previousChannels.psubscribe.length) {\n    var pending = 0;\n    _.forEach(['subscribe', 'psubscribe'], function (type) {\n      var channels = previousChannels[type];\n      if (channels.length) {\n        pending += 1;\n        debug('%s %d channels', type, channels.length);\n        _this.subscriber[type](channels).then(function () {\n          if (!--pending) {\n            _this.lastActiveSubscriber = _this.subscriber;\n          }\n        }).catch(_.noop);\n      }\n    });\n  } else {\n    if (this.subscriber.status === 'wait') {\n      this.subscriber.connect().catch(_.noop);\n    }\n    this.lastActiveSubscriber = this.subscriber;\n  }\n  _.forEach(['message', 'messageBuffer'], function (event) {\n    _this.subscriber.on(event, function (arg1, arg2) {\n      _this.emit(event, arg1, arg2);\n    });\n  });\n  _.forEach(['pmessage', 'pmessageBuffer'], function (event) {\n    _this.subscriber.on(event, function (arg1, arg2, arg3) {\n      _this.emit(event, arg1, arg2, arg3);\n    });\n  });\n};\n\n/**\n * Change cluster instance's status\n *\n * @param {string} status\n * @private\n */\nCluster.prototype.setStatus = function (status) {\n  debug('status: %s -> %s', this.status || '[empty]', status);\n  this.status = status;\n  process.nextTick(this.emit.bind(this, status));\n};\n\n/**\n * Refresh the slot cache\n *\n * @param {function} callback\n * @private\n */\nCluster.prototype.refreshSlotsCache = function (callback) {\n  if (this.isRefreshing) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback);\n    }\n    return;\n  }\n  this.isRefreshing = true;\n\n  var _this = this;\n  var wrapper = function () {\n    _this.isRefreshing = false;\n    if (typeof callback === 'function') {\n      callback.apply(null, arguments);\n    }\n  };\n\n  var keys = _.shuffle(Object.keys(this.connectionPool.nodes.all));\n\n  var lastNodeError = null;\n\n  function tryNode(index) {\n    if (index === keys.length) {\n      var error = new Error('Failed to refresh slots cache.');\n      error.lastNodeError = lastNodeError;\n      return wrapper(error);\n    }\n    debug('getting slot cache from %s', keys[index]);\n    _this.getInfoFromNode(_this.connectionPool.nodes.all[keys[index]], function (err) {\n      if (_this.status === 'end') {\n        return wrapper(new Error('Cluster is disconnected.'));\n      }\n      if (err) {\n        _this.emit('node error', err);\n        lastNodeError = err;\n        tryNode(index + 1);\n      } else {\n        _this.emit('refresh');\n        wrapper();\n      }\n    });\n  }\n\n  tryNode(0);\n};\n\n/**\n * Flush offline queue with error.\n *\n * @param {Error} error - The error object to send to the commands\n * @private\n */\nCluster.prototype.flushQueue = function (error) {\n  var item;\n  while (this.offlineQueue.length > 0) {\n    item = this.offlineQueue.shift();\n    item.command.reject(error);\n  }\n};\n\nCluster.prototype.executeOfflineCommands = function () {\n  if (this.offlineQueue.length) {\n    debug('send %d commands in offline queue', this.offlineQueue.length);\n    var offlineQueue = this.offlineQueue;\n    this.resetOfflineQueue();\n    while (offlineQueue.length > 0) {\n      var item = offlineQueue.shift();\n      this.sendCommand(item.command, item.stream, item.node);\n    }\n  }\n};\n\nCluster.prototype.sendCommand = function (command, stream, node) {\n  if (this.status === 'wait') {\n    this.connect().catch(_.noop);\n  }\n  if (this.status === 'end') {\n    command.reject(new Error(utils.CONNECTION_CLOSED_ERROR_MSG));\n    return command.promise;\n  }\n  var to = this.options.scaleReads;\n  if (to !== 'master') {\n    var isCommandReadOnly = commands.exists(command.name) && commands.hasFlag(command.name, 'readonly');\n    if (!isCommandReadOnly) {\n      to = 'master';\n    }\n  }\n\n  var targetSlot = node ? node.slot : command.getSlot();\n  var ttl = {};\n  var _this = this;\n  if (!node && !command.__is_reject_overwritten) {\n    command.__is_reject_overwritten = true;\n    var reject = command.reject;\n    command.reject = function (err) {\n      var partialTry = _.partial(tryConnection, true);\n      _this.handleError(err, ttl, {\n        moved: function (slot, key) {\n          debug('command %s is moved to %s', command.name, key);\n          if (_this.slots[slot]) {\n            _this.slots[slot][0] = key;\n          } else {\n            _this.slots[slot] = [key];\n          }\n          var splitKey = key.split(':');\n          _this.connectionPool.findOrCreate({ host: splitKey[0], port: Number(splitKey[1]) });\n          tryConnection();\n          _this.refreshSlotsCache();\n        },\n        ask: function (slot, key) {\n          debug('command %s is required to ask %s:%s', command.name, key);\n          var splitKey = key.split(':');\n          _this.connectionPool.findOrCreate({ host: splitKey[0], port: Number(splitKey[1]) });\n          tryConnection(false, key);\n        },\n        tryagain: partialTry,\n        clusterDown: partialTry,\n        connectionClosed: partialTry,\n        maxRedirections: function (redirectionError) {\n          reject.call(command, redirectionError);\n        },\n        defaults: function () {\n          reject.call(command, err);\n        }\n      });\n    };\n  }\n  tryConnection();\n\n  function tryConnection(random, asking) {\n    if (_this.status === 'end') {\n      command.reject(new Error('Cluster is ended.'));\n      return;\n    }\n    var redis;\n    if (_this.status === 'ready' || (command.name === 'cluster')) {\n      if (node && node.redis) {\n        redis = node.redis;\n      } else if (Command.checkFlag('ENTER_SUBSCRIBER_MODE', command.name) ||\n                 Command.checkFlag('EXIT_SUBSCRIBER_MODE', command.name)) {\n        redis = _this.subscriber;\n      } else {\n        if (!random) {\n          if (typeof targetSlot === 'number' && _this.slots[targetSlot]) {\n            var nodeKeys = _this.slots[targetSlot];\n            if (typeof to === 'function') {\n              var nodes =\n                  nodeKeys\n                  .map(function (key) {\n                    return _this.connectionPool.nodes.all[key];\n                  });\n              redis = to(nodes, command);\n              if (Array.isArray(redis)) {\n                redis = utils.sample(redis);\n              }\n              if (!redis) {\n                redis = nodes[0];\n              }\n            } else {\n              var key;\n              if (to === 'all') {\n                key = utils.sample(nodeKeys);\n              } else if (to === 'slave' && nodeKeys.length > 1) {\n                key = utils.sample(nodeKeys, 1);\n              } else {\n                key = nodeKeys[0];\n              }\n              redis = _this.connectionPool.nodes.all[key];\n            }\n          }\n          if (asking) {\n            redis = _this.connectionPool.nodes.all[asking];\n            redis.asking();\n          }\n        }\n        if (!redis) {\n          redis = _.sample(_this.connectionPool.nodes[to]) ||\n            _.sample(_this.connectionPool.nodes.all);\n        }\n      }\n      if (node && !node.redis) {\n        node.redis = redis;\n      }\n    }\n    if (redis) {\n      redis.sendCommand(command, stream);\n    } else if (_this.options.enableOfflineQueue) {\n      _this.offlineQueue.push({\n        command: command,\n        stream: stream,\n        node: node\n      });\n    } else {\n      command.reject(new Error('Cluster isn\\'t ready and enableOfflineQueue options is false'));\n    }\n  }\n  return command.promise;\n};\n\nCluster.prototype.handleError = function (error, ttl, handlers) {\n  if (typeof ttl.value === 'undefined') {\n    ttl.value = this.options.maxRedirections;\n  } else {\n    ttl.value -= 1;\n  }\n  if (ttl.value <= 0) {\n    handlers.maxRedirections(new Error('Too many Cluster redirections. Last error: ' + error));\n    return;\n  }\n  var errv = error.message.split(' ');\n  if (errv[0] === 'MOVED' || errv[0] === 'ASK') {\n    handlers[errv[0] === 'MOVED' ? 'moved' : 'ask'](errv[1], errv[2]);\n  } else if (errv[0] === 'TRYAGAIN') {\n    this.delayQueue.push('tryagain', handlers.tryagain, {\n      timeout: this.options.retryDelayOnTryAgain\n    });\n  } else if (errv[0] === 'CLUSTERDOWN' && this.options.retryDelayOnClusterDown > 0) {\n    this.delayQueue.push('clusterdown', handlers.connectionClosed, {\n      timeout: this.options.retryDelayOnClusterDown,\n      callback: this.refreshSlotsCache.bind(this)\n    });\n  } else if (error.message === utils.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0) {\n    this.delayQueue.push('failover', handlers.connectionClosed, {\n      timeout: this.options.retryDelayOnFailover,\n      callback: this.refreshSlotsCache.bind(this)\n    });\n  } else {\n    handlers.defaults();\n  }\n};\n\nCluster.prototype.getInfoFromNode = function (redis, callback) {\n  if (!redis) {\n    return callback(new Error('Node is disconnected'));\n  }\n  var _this = this;\n  redis.cluster('slots', utils.timeout(function (err, result) {\n    if (err) {\n      redis.disconnect();\n      return callback(err);\n    }\n    var nodes = [];\n\n    for (var i = 0; i < result.length; ++i) {\n      var items = result[i];\n      var slotRangeStart = items[0];\n      var slotRangeEnd = items[1];\n\n      var keys = [];\n      for (var j = 2; j < items.length; j++) {\n        items[j] = { host: items[j][0], port: items[j][1] };\n        items[j].readOnly = j !== 2;\n        nodes.push(items[j]);\n        keys.push(items[j].host + ':' + items[j].port);\n      }\n\n      for (var slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n        _this.slots[slot] = keys;\n      }\n    }\n\n    _this.connectionPool.reset(nodes);\n    callback();\n  }, 1000));\n};\n\n/**\n * Check whether Cluster is able to process commands\n *\n * @param {Function} callback\n * @private\n */\nCluster.prototype._readyCheck = function (callback) {\n  this.cluster('info', function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (typeof res !== 'string') {\n      return callback();\n    }\n\n    var state;\n    var lines = res.split('\\r\\n');\n    for (var i = 0; i < lines.length; ++i) {\n      var parts = lines[i].split(':');\n      if (parts[0] === 'cluster_state') {\n        state = parts[1];\n        break;\n      }\n    }\n\n    if (state === 'fail') {\n      debug('cluster state not ok (%s)', state);\n      callback(null, state);\n    } else {\n      callback();\n    }\n  });\n};\n\n['sscan', 'hscan', 'zscan', 'sscanBuffer', 'hscanBuffer', 'zscanBuffer']\n.forEach(function (command) {\n  Cluster.prototype[command + 'Stream'] = function (key, options) {\n    return new ScanStream(_.defaults({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command\n    }, options));\n  };\n});\n\nrequire('../transaction').addTransactionSupport(Cluster.prototype);\n\nmodule.exports = Cluster;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/cluster/connection_pool.js":"'use strict';\n\nvar util = require('util');\nvar utils = require('../utils');\nvar EventEmitter = require('events').EventEmitter;\nvar _ = require('lodash');\nvar Redis = require('../redis');\n\nfunction ConnectionPool(redisOptions) {\n  EventEmitter.call(this);\n  this.redisOptions = redisOptions;\n\n  // master + slave = all\n  this.nodes = {\n    all: {},\n    master: {},\n    slave: {}\n  };\n\n  this.specifiedOptions = {};\n}\n\nutil.inherits(ConnectionPool, EventEmitter);\n\n/**\n * Find or create a connection to the node\n *\n * @param {Object} node - the node to connect to\n * @param {boolean} [readOnly=false] - whether the node is a slave\n * @return {Redis}\n * @public\n */\nConnectionPool.prototype.findOrCreate = function (node, readOnly) {\n  setKey(node);\n  readOnly = Boolean(readOnly);\n\n  if (this.specifiedOptions[node.key]) {\n    _.assign(node, this.specifiedOptions[node.key]);\n  } else {\n    this.specifiedOptions[node.key] = node;\n  }\n\n  var redis;\n  if (this.nodes.all[node.key]) {\n    redis = this.nodes.all[node.key];\n    if (redis.options.readOnly !== readOnly) {\n      redis.options.readOnly = readOnly;\n      redis[readOnly ? 'readonly' : 'readwrite']().catch(_.noop);\n      if (readOnly) {\n        delete this.nodes.master[node.key];\n        this.nodes.slave[node.key] = redis;\n      } else {\n        delete this.nodes.slave[node.key];\n        this.nodes.master[node.key] = redis;\n      }\n    }\n  } else {\n    redis = new Redis(_.defaults({\n      retryStrategy: null,\n      readOnly: readOnly\n    }, node, this.redisOptions, { lazyConnect: true }));\n    this.nodes.all[node.key] = redis;\n    this.nodes[readOnly ? 'slave' : 'master'][node.key] = redis;\n\n    var _this = this;\n    redis.once('end', function () {\n      delete _this.nodes.all[node.key];\n      delete _this.nodes.master[node.key];\n      delete _this.nodes.slave[node.key];\n      _this.emit('-node', redis);\n      if (!Object.keys(_this.nodes.all).length) {\n        _this.emit('drain');\n      }\n    });\n\n    this.emit('+node', redis);\n\n    redis.on('error', function (error) {\n      _this.emit('nodeError', error);\n    });\n  }\n\n  return redis;\n};\n\n/**\n * Reset the pool with a set of nodes.\n * The old node will be removed.\n *\n * @param {Object[]} nodes\n * @public\n */\nConnectionPool.prototype.reset = function (nodes) {\n  var newNodes = {};\n  nodes.forEach(function (node) {\n    var options = {};\n    if (typeof node === 'object') {\n      _.defaults(options, node);\n    } else if (typeof node === 'string') {\n      _.defaults(options, utils.parseURL(node));\n    } else if (typeof node === 'number') {\n      options.port = node;\n    } else {\n      throw new Error('Invalid argument ' + node);\n    }\n    if (typeof options.port === 'string') {\n      options.port = parseInt(options.port, 10);\n    }\n    delete options.db;\n\n    setKey(options);\n    newNodes[options.key] = options;\n  }, this);\n\n  var _this = this;\n  Object.keys(this.nodes.all).forEach(function (key) {\n    if (!newNodes[key]) {\n      _this.nodes.all[key].disconnect();\n    }\n  });\n  Object.keys(newNodes).forEach(function (key) {\n    _this.findOrCreate(newNodes[key], newNodes[key].readOnly);\n  });\n};\n\n/**\n * Set key property\n *\n * @private\n */\nfunction setKey(node) {\n  node = node || {};\n  node.port = node.port || 6379;\n  node.host = node.host || '127.0.0.1';\n  node.key = node.key || node.host + ':' + node.port;\n  return node;\n}\n\nmodule.exports = ConnectionPool;\n","/home/travis/build/npmtest/node-npmtest-ioredis/node_modules/ioredis/lib/cluster/delay_queue.js":"'use strict';\n\nvar Deque = require('double-ended-queue');\nvar debug = require('debug')('ioredis:delayqueue');\n\nfunction DelayQueue() {\n  this.queues = {};\n  this.timeouts = {};\n}\n\nDelayQueue.prototype.push = function (bucket, item, options) {\n  var callback = options.callback || process.nextTick;\n  if (!this.queues[bucket]) {\n    this.queues[bucket] = new Deque();\n  }\n\n  var queue = this.queues[bucket];\n  queue.push(item);\n\n  if (!this.timeouts[bucket]) {\n    var _this = this;\n    this.timeouts[bucket] = setTimeout(function () {\n      callback(function () {\n        _this.timeouts[bucket] = null;\n        _this._execute(bucket);\n      });\n    }, options.timeout);\n  }\n};\n\nDelayQueue.prototype._execute = function (bucket) {\n  var queue = this.queues[bucket];\n  if (!queue) {\n    return;\n  }\n  var length = queue.length;\n  if (!length) {\n    return;\n  }\n  debug('send %d commands in %s queue', length, bucket);\n\n  this.queues[bucket] = null;\n  while (queue.length > 0) {\n    queue.shift()();\n  }\n};\n\nmodule.exports = DelayQueue;\n"}